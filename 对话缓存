æˆ‘å¸Œæœ›ä½ å¸®æˆ‘é›†æˆ,ä¸è¿‡æˆ‘å¸Œæœ›ä½ å…ˆçœ‹ä¸€ä¸‹,æˆ‘ç°åœ¨çš„å®é™…ä»£ç ,ä¸è¦å¸¦ç€å¹»è§‰æ”¹.



æ–‡ä»¶ `src/ui.js`:



```javascript

/**

* UI æ¨¡å— - ä¾§è¾¹æ å’Œæ–‡ä»¶æ ‘æ¸²æŸ“

*/



import { fs } from './fs.js';

import { gemini } from './gemini.js';

import { getLanguage, showToast, estimateTokens, formatTokens } from './utils.js';

import { initThemeStyle, updateTheme } from './theme.js';

import { showHistoryDialog } from './dialog.js';

import { getSystemPrompt } from './prompt.js';

import { depsAnalyzer } from './deps.js';



class UI {

constructor() {

this.folderStates = new Map();

this.currentTree = null;

}



init() {

if (document.getElementById('ide-bridge-root')) return;


const root = document.createElement('div');

root.id = 'ide-bridge-root';


root.appendChild(this._createSidebar());

root.appendChild(this._createTrigger());

root.appendChild(this._createContextMenu());


// ğŸ¨ æ³¨å…¥ä¸»é¢˜æ ·å¼ (ä½¿ç”¨ theme.js æ¨¡å—)

root.appendChild(initThemeStyle());



document.body.appendChild(root);


// ç›‘å¬ä¸»é¢˜å˜åŒ–ï¼ˆå®šæ—¶æ£€æµ‹ï¼Œå› ä¸º Gemini å¯èƒ½åŠ¨æ€åˆ‡æ¢ï¼‰

setInterval(() => updateTheme(), 2000);


document.addEventListener('click', () => {

const menu = document.getElementById('ide-context-menu');

if (menu) menu.style.display = 'none';

});



// ç›‘å¬æ–‡ä»¶æ ‘åˆ·æ–°äº‹ä»¶

window.addEventListener('ide-refresh-tree', () => {

if (this.currentTree) {

this.refreshTree(); // ğŸ‘ˆ æ”¹ä¸ºè°ƒç”¨é™é»˜åˆ·æ–°

}

});

}



// ğŸ”„ æ–°å¢ï¼šé™é»˜åˆ·æ–° UI

async refreshTree() {

const result = await fs.refreshProject();

if (result.success) {

this.currentTree = result.tree;

this._renderTree(result.tree);

// æ›´æ–°è§¦å‘å™¨çŠ¶æ€

const trigger = document.getElementById('ide-trigger');

if (trigger && result.rootName) {

trigger.textContent = 'âœ… ' + result.rootName;

}

}

}



// ğŸ›¡ï¸ å®‰å…¨çš„ SVG å›¾æ ‡ç”Ÿæˆå™¨ (Trusted Types Safe)

_createIcon(name, size = 14, color = 'currentColor') {

const icons = {

folder: 'M3 7v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-6l-2-2H5a2 2 0 0 0-2 2z',

file: 'M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z M13 2v7h7',

logo: 'M16 18l6-6-6-6 M8 6l-6 6 6 6 M12.5 4l-3 16',

close: 'M18 6L6 18M6 6l12 12',

arrowRight: 'M9 18l6-6-6-6',

arrowDown: 'M6 9l6 6 6-6'

};



const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

svg.setAttribute('width', size);

svg.setAttribute('height', size);

svg.setAttribute('viewBox', '0 0 24 24');

svg.setAttribute('fill', 'none');

svg.setAttribute('stroke', color);

svg.setAttribute('stroke-width', '2');

svg.setAttribute('stroke-linecap', 'round');

svg.setAttribute('stroke-linejoin', 'round');

svg.classList.add('ide-icon');



const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

path.setAttribute('d', icons[name] || icons.file);

svg.appendChild(path);


return svg;

}



_createTrigger() {

const trigger = document.createElement('div');

trigger.id = 'ide-trigger';

trigger.textContent = 'âš¡ï¸';

Object.assign(trigger.style, {

position: 'fixed', bottom: '20px', right: '20px', // æ”¹åˆ°å³ä¸‹è§’ï¼Œç¬¦åˆå·¥å…·ç›´è§‰

zIndex: '2147483646', width: '40px', height: '40px',

background: 'var(--ide-bg)', color: 'var(--ide-text)',

border: '1px solid var(--ide-border)', borderRadius: '50%',

display: 'flex', alignItems: 'center', justifyContent: 'center',

cursor: 'pointer', boxShadow: 'var(--ide-shadow)',

fontSize: '18px', transition: 'all 0.2s', userSelect: 'none'

});


trigger.classList.add('ide-glass'); // æ·»åŠ æ¯›ç»ç’ƒ



// æ‚¬åœå±•å¼€æ•ˆæœ

trigger.onmouseover = () => {

trigger.style.width = 'auto';

trigger.style.borderRadius = '20px';

trigger.style.padding = '0 12px';

trigger.textContent = 'âš¡ï¸ IDE Bridge';

};

trigger.onmouseout = () => {

// å¦‚æœæ²¡è¿æ¥é¡¹ç›®ï¼Œæ¢å¤åŸçŠ¶

if (!this.currentTree) {

trigger.style.width = '40px';

trigger.style.padding = '0';

trigger.style.borderRadius = '50%';

trigger.textContent = 'âš¡ï¸';

}

};



trigger.onclick = () => {

const sidebar = document.getElementById('ide-sidebar');

// åˆ‡æ¢æ˜¾ç¤ºçŠ¶æ€

const isHidden = sidebar.style.transform === 'translateX(100%)';

sidebar.style.transform = isHidden ? 'translateX(0)' : 'translateX(100%)';

};

return trigger;

}



_createSidebar() {

const sidebar = document.createElement('div');

sidebar.id = 'ide-sidebar';

sidebar.classList.add('ide-glass'); // ä½¿ç”¨ CSS ç±»æ§åˆ¶èƒŒæ™¯


Object.assign(sidebar.style, {

position: 'fixed', right: '0', top: '0',

width: '360px', height: '100vh',

background: 'var(--ide-bg)', // ä½¿ç”¨å˜é‡

borderLeft: '1px solid var(--ide-border)',

zIndex: '2147483647',

transition: 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)', // æ›´å¹³æ»‘çš„åŠ¨ç”»

transform: 'translateX(100%)', // é»˜è®¤éšè— (ä½¿ç”¨ transform æ€§èƒ½æ›´å¥½)

color: 'var(--ide-text)', display: 'flex', flexDirection: 'column',

boxShadow: 'var(--ide-shadow)',

fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',

fontSize: '13px', lineHeight: '1.5'

});



// æ ‡é¢˜æ 

const header = document.createElement('div');

Object.assign(header.style, {

padding: '12px 16px', borderBottom: '1px solid var(--ide-border)',

display: 'flex', justifyContent: 'space-between', alignItems: 'center',

background: 'transparent' // é€æ˜èƒŒæ™¯ï¼Œé€å‡º sidebar çš„ glass æ•ˆæœ

});


const title = document.createElement('div');

title.style.display = 'flex';

title.style.alignItems = 'center';

title.style.gap = '8px';

title.style.fontWeight = '600';

title.style.color = 'var(--ide-text)';

title.style.fontSize = '14px';


const logoIcon = this._createIcon('logo', 16, 'var(--ide-accent)');

const titleText = document.createElement('span');

titleText.textContent = 'Gemini IDE';


// æ–°å¢ï¼šåœ¨çº¿çŠ¶æ€æŒ‡ç¤ºç¯

const statusDot = document.createElement('div');

Object.assign(statusDot.style, {

width: '8px', height: '8px', borderRadius: '50%',

background: '#059669', marginLeft: '4px',

boxShadow: '0 0 8px #059669',

display: this.currentTree ? 'block' : 'none'

});

statusDot.id = 'ide-status-dot';


title.appendChild(logoIcon);

title.appendChild(titleText);

title.appendChild(statusDot);


const closeBtn = document.createElement('button');

closeBtn.style.display = 'flex';

closeBtn.appendChild(this._createIcon('close', 18, 'var(--ide-text-secondary)'));

Object.assign(closeBtn.style, {

background: 'none', border: 'none',

cursor: 'pointer', padding: '4px', opacity: '0.7', transition: 'opacity 0.2s'

});

closeBtn.onmouseover = () => closeBtn.style.opacity = '1';

closeBtn.onmouseout = () => closeBtn.style.opacity = '0.7';

closeBtn.onclick = () => { sidebar.style.transform = 'translateX(100%)'; };


header.appendChild(title);

header.appendChild(closeBtn);

sidebar.appendChild(header);



// æ“ä½œæ 

const actionBar = document.createElement('div');

actionBar.id = 'ide-action-bar';

Object.assign(actionBar.style, {

padding: '10px', borderBottom: '1px solid var(--ide-border)',

display: 'none', gap: '8px'

});

sidebar.appendChild(actionBar);



// æ–‡ä»¶æ ‘

const treeContainer = document.createElement('div');

treeContainer.id = 'ide-tree-container';

Object.assign(treeContainer.style, {

flex: '1', overflowY: 'auto', padding: '8px', fontSize: '13px'

});


// ç©ºçŠ¶æ€

const emptyState = this._createEmptyState();

treeContainer.appendChild(emptyState);

sidebar.appendChild(treeContainer);



// åº•éƒ¨

const footer = document.createElement('div');

Object.assign(footer.style, {

padding: '8px', borderTop: '1px solid var(--ide-border)',

fontSize: '10px', color: 'var(--ide-text-secondary)', textAlign: 'center'

});

footer.textContent = 'V1.0.0 | æ”¯æŒç‰ˆæœ¬å›é€€';

sidebar.appendChild(footer);



return sidebar;

}



_createEmptyState() {

const emptyState = document.createElement('div');

Object.assign(emptyState.style, { textAlign: 'center', marginTop: '100px', color: '#6b7280' });


const icon = document.createElement('div');

icon.textContent = 'ğŸ“';

icon.style.fontSize = '40px';

icon.style.marginBottom = '16px';


const text = document.createElement('p');

text.textContent = 'æœªè¿æ¥æœ¬åœ°é¡¹ç›®';


const connectBtn = document.createElement('button');

connectBtn.id = 'ide-action-connect';

connectBtn.textContent = 'è¿æ¥æ–‡ä»¶å¤¹';

Object.assign(connectBtn.style, {

marginTop: '16px', background: '#2563eb', color: 'white',

border: 'none', padding: '10px 24px', borderRadius: '6px',

cursor: 'pointer', fontWeight: 'bold'

});

connectBtn.onclick = () => this.handleConnect();


emptyState.appendChild(icon);

emptyState.appendChild(text);

emptyState.appendChild(connectBtn);

return emptyState;

}



_createContextMenu() {

const menu = document.createElement('div');

menu.id = 'ide-context-menu';

// ğŸ¨ ç§»é™¤å›ºå®šè‰²å€¼ï¼Œæ”¹ç”¨ä¸»é¢˜å˜é‡é€‚é…äº®/æš—æ¨¡å¼

Object.assign(menu.style, {

position: 'fixed', display: 'none',

background: 'var(--ide-bg)',

border: '1px solid var(--ide-border)',

borderRadius: '6px',

boxShadow: 'var(--ide-shadow)',

zIndex: '2147483648',

minWidth: '160px', padding: '4px 0',

backdropFilter: 'blur(12px)'

});

return menu;

}



async handleConnect() {

const connectBtn = document.getElementById('ide-action-connect');

if (connectBtn) connectBtn.textContent = 'è¿æ¥ä¸­...';


const result = await fs.openProject();


if (result.success) {

this.currentTree = result.tree;


const trigger = document.getElementById('ide-trigger');

if (trigger) {

trigger.textContent = 'âœ… ' + result.rootName;

trigger.style.background = '#059669';

trigger.style.borderColor = '#34d399';

}


this._renderActionBar();

this._renderTree(result.tree);



// æ›´æ–°çŠ¶æ€ç¯

const dot = document.getElementById('ide-status-dot');

if (dot) dot.style.display = 'block';


// å¼€å§‹ç›‘å¬ AI è¾“å‡º

gemini.startWatching();

} else {

if (connectBtn) connectBtn.textContent = 'è¿æ¥æ–‡ä»¶å¤¹';

}

}



_renderActionBar() {

const actionBar = document.getElementById('ide-action-bar');

if (!actionBar) return;


// å®¹å™¨æ ·å¼ä¼˜åŒ–

Object.assign(actionBar.style, {

display: 'flex', gap: '8px', padding: '12px 16px',

borderBottom: '1px solid var(--ide-border)',

background: 'transparent'

});



while (actionBar.firstChild) actionBar.removeChild(actionBar.firstChild);


// 1. æç¤ºè¯

const promptBtn = this._createButton('ğŸ¤– æç¤ºè¯', () => {

const result = gemini.insertToInput(getSystemPrompt());

if (result.success) {

showToast(`å·²å‘é€ç³»ç»Ÿåè®® (~${formatTokens(result.tokens)} tokens)`);

}

});

// ç§»é™¤ primary ç±»ï¼Œå›å½’ç»Ÿä¸€çš„ Ghost é£æ ¼

actionBar.appendChild(promptBtn);



// 2. å‘é€ç›®å½•

const sendBtn = this._createButton('ğŸ“‹ å‘é€ç›®å½•', () => {

const structure = fs.generateFullStructure(this.currentTree);

const text = `é¡¹ç›® "${fs.projectName}" ç›®å½•:\n\n\`\`\`\n${structure}\`\`\``;

const result = gemini.insertToInput(text);

if (result.success) {

showToast(`å·²å‘é€ç›®å½• (~${formatTokens(result.tokens)} tokens)`);

}

});

actionBar.appendChild(sendBtn);


// 3. åˆ·æ–°

const refreshBtn = this._createButton('ğŸ”„ åˆ·æ–°', () => this.refreshTree());

actionBar.appendChild(refreshBtn);

}



// ä½¿ç”¨çº¯ CSS ç±»æ§åˆ¶æ ·å¼ï¼Œé¿å… JS é—ªçƒ

_createButton(text, onClick) {

const btn = document.createElement('button');

btn.textContent = text;

btn.className = 'ide-btn'; // åº”ç”¨ CSS ç±»

btn.onclick = onClick;

return btn;

}



_renderTree(tree) {

const container = document.getElementById('ide-tree-container');

if (!container) return;


while (container.firstChild) container.removeChild(container.firstChild);


const hint = document.createElement('div');

Object.assign(hint.style, {

padding: '6px 8px', marginBottom: '8px', background: 'var(--ide-hint-bg)',

borderRadius: '4px', fontSize: '11px', color: 'var(--ide-hint-text)'

});

hint.textContent = 'ğŸ’¡ ç‚¹å‡»æ–‡ä»¶å‘é€ | å³é”®æ–‡ä»¶å¤¹æ›´å¤š';

container.appendChild(hint);


this._buildTreeNodes(container, tree, 0);

}



_buildTreeNodes(container, nodes, level) {

nodes.forEach(node => {

const item = document.createElement('div');

Object.assign(item.style, {

padding: '5px 4px', paddingLeft: (level * 14 + 4) + 'px',

whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis',

cursor: 'pointer', borderRadius: '3px', margin: '1px 0',

display: 'flex', alignItems: 'center', gap: '4px'

});

item.title = node.path;

item.classList.add('ide-tree-item'); // ä½¿ç”¨ class æ§åˆ¶ hover

// ç§»é™¤åŸæœ¬çš„ JS hover é€»è¾‘

// item.onmouseover = ...

// item.onmouseout = ...



if (node.kind === 'directory') {

const isExpanded = this.folderStates.get(node.path) || false;


const arrow = this._createIcon(isExpanded ? 'arrowDown' : 'arrowRight', 12, 'var(--ide-text-secondary)');

Object.assign(arrow.style, { width: '16px', minWidth: '16px' });


const icon = this._createIcon('folder', 14, 'var(--ide-text-folder)');


const name = document.createElement('span');

name.textContent = node.name;

name.style.color = 'var(--ide-text)';

name.style.fontWeight = '500';


item.appendChild(arrow);

item.appendChild(icon);

item.appendChild(name);


item.onclick = () => {

this.folderStates.set(node.path, !isExpanded);

this._renderTree(this.currentTree);

};


item.oncontextmenu = (e) => this._showContextMenu(e, node);


container.appendChild(item);


if (isExpanded && node.children) {

this._buildTreeNodes(container, node.children, level + 1);

}

} else {

const spacer = document.createElement('span');

spacer.style.width = '16px';

spacer.style.minWidth = '16px';


const icon = this._createIcon('file', 14, 'var(--ide-text-secondary)');


const name = document.createElement('span');

name.textContent = node.name;

name.style.color = 'var(--ide-text-secondary)';


item.appendChild(spacer);

item.appendChild(icon);

item.appendChild(name);


item.onclick = async () => {

item.style.opacity = '0.5';

const content = await fs.readFile(node.path);

item.style.opacity = '1';


if (content !== null) {

gemini.sendFile(node.path, content);

// sendFile å†…éƒ¨å·²ç» showToast äº†

}

};



// æ–‡ä»¶å³é”®èœå•

item.oncontextmenu = (e) => this._showFileContextMenu(e, node);


container.appendChild(item);

}

});

}



_showContextMenu(e, node) {

e.preventDefault();

e.stopPropagation();


const menu = document.getElementById('ide-context-menu');

if (!menu) return;


while (menu.firstChild) menu.removeChild(menu.firstChild);


// å‘é€ç›®å½•ç»“æ„

menu.appendChild(this._createMenuItem('ğŸ“‹ å‘é€ç›®å½•ç»“æ„', () => {

const structure = fs.generateStructure(node);

gemini.sendStructure(node.path, structure);

}));


// å‘é€æ‰€æœ‰æ–‡ä»¶

menu.appendChild(this._createMenuItem('ğŸ“¦ å‘é€æ‰€æœ‰æ–‡ä»¶', async () => {

showToast('è¯»å–ä¸­...', 'info');

const content = await this._collectFiles(node);

const result = gemini.insertToInput(content);

if (result.success) {

showToast(`å·²å‘é€ (~${formatTokens(result.tokens)} tokens)`);

}

}));



// åˆ†éš”çº¿

menu.appendChild(this._createMenuDivider());



// æ–°å»ºæ–‡ä»¶

menu.appendChild(this._createMenuItem('â• æ–°å»ºæ–‡ä»¶', async () => {

const fileName = prompt('è¾“å…¥æ–‡ä»¶å:');

if (!fileName || !fileName.trim()) return;

const newPath = node.path + '/' + fileName.trim();

if (await fs.createFile(newPath, '')) {

showToast('å·²åˆ›å»º: ' + fileName);

await this.refreshTree(); // ğŸ‘ˆ ä¿®å¤ï¼šé™é»˜åˆ·æ–°

} else {

showToast('åˆ›å»ºå¤±è´¥', 'error');

}

}));



// æ–°å»ºæ–‡ä»¶å¤¹

menu.appendChild(this._createMenuItem('ğŸ“ æ–°å»ºæ–‡ä»¶å¤¹', async () => {

const folderName = prompt('è¾“å…¥æ–‡ä»¶å¤¹å:');

if (!folderName || !folderName.trim()) return;

const newPath = node.path + '/' + folderName.trim() + '/.gitkeep';

if (await fs.createFile(newPath, '')) {

showToast('å·²åˆ›å»º: ' + folderName);

await this.refreshTree(); // ğŸ‘ˆ ä¿®å¤ï¼šé™é»˜åˆ·æ–°

} else {

showToast('åˆ›å»ºå¤±è´¥', 'error');

}

}));



// åˆ†éš”çº¿

menu.appendChild(this._createMenuDivider());



// åˆ é™¤ç›®å½•

menu.appendChild(this._createMenuItem('ğŸ—‘ï¸ åˆ é™¤ç›®å½•', async () => {

if (!confirm(`ç¡®å®šåˆ é™¤ç›®å½• "${node.name}" åŠå…¶æ‰€æœ‰å†…å®¹ï¼Ÿ\n\nâš ï¸ æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼`)) return;

if (await fs.deleteDirectory(node.path)) {

showToast('å·²åˆ é™¤: ' + node.name);

await this.refreshTree(); // ğŸ‘ˆ ä¿®å¤ï¼šé™é»˜åˆ·æ–°

} else {

showToast('åˆ é™¤å¤±è´¥', 'error');

}

}, '#dc2626'));


menu.style.display = 'block';

menu.style.left = Math.min(e.clientX, window.innerWidth - 180) + 'px';

menu.style.top = Math.min(e.clientY, window.innerHeight - 150) + 'px';

}



/**

* æ–‡ä»¶å³é”®èœå•

*/

_showFileContextMenu(e, node) {

e.preventDefault();

e.stopPropagation();


const menu = document.getElementById('ide-context-menu');

if (!menu) return;


while (menu.firstChild) menu.removeChild(menu.firstChild);



// å‘é€æ–‡ä»¶

menu.appendChild(this._createMenuItem('ğŸ“¤ å‘é€åˆ°å¯¹è¯', async () => {

const content = await fs.readFile(node.path);

if (content !== null) {

gemini.sendFile(node.path, content);

}

}));



// å‘é€æ–‡ä»¶åŠä¾èµ–

const fileType = depsAnalyzer.getFileType(node.path);

if (fileType) {

menu.appendChild(this._createMenuItem('ğŸ”— å‘é€æ–‡ä»¶+ä¾èµ–', async () => {

showToast('åˆ†æä¾èµ–ä¸­...', 'info');

const { all } = await depsAnalyzer.getFileWithDeps(node.path);


if (all.length === 1) {

// æ²¡æœ‰ä¾èµ–ï¼Œç›´æ¥å‘é€

const content = await fs.readFile(node.path);

if (content !== null) {

gemini.sendFile(node.path, content);

}

return;

}


// æœ‰ä¾èµ–ï¼Œæ‰“åŒ…å‘é€

let text = `æ–‡ä»¶ \`${node.path}\` åŠå…¶ ${all.length - 1} ä¸ªä¾èµ–:\n\n`;

for (const filePath of all) {

const content = await fs.readFile(filePath);

if (content !== null) {

const lang = getLanguage(filePath);

text += `### ${filePath}\n\`\`\`${lang}\n${content}\n\`\`\`\n\n`;

}

}


const result = gemini.insertToInput(text);

if (result.success) {

showToast(`å·²å‘é€ ${all.length} ä¸ªæ–‡ä»¶ (~${formatTokens(result.tokens)} tokens)`);

}

}));

}



// åˆ†éš”çº¿

menu.appendChild(this._createMenuDivider());



// æŸ¥çœ‹å†å²ç‰ˆæœ¬

menu.appendChild(this._createMenuItem('âª å†å²ç‰ˆæœ¬', async () => {

// ç›´æ¥è°ƒç”¨ï¼Œä¸å†ä¼ é€’å·²åˆ é™¤çš„ showCodeReader å›è°ƒ

await showHistoryDialog(node.path);

}));



// å¿«é€Ÿæ’¤é”€

menu.appendChild(this._createMenuItem('â†©ï¸ æ’¤é”€ä¸Šæ¬¡ä¿®æ”¹', async () => {

const result = await fs.revertFile(node.path);

if (result.success) {

showToast('å·²æ’¤é”€');

} else {

showToast(result.error || 'æ’¤é”€å¤±è´¥', 'error');

}

}));



// åˆ†éš”çº¿

menu.appendChild(this._createMenuDivider());



// åˆ é™¤æ–‡ä»¶

menu.appendChild(this._createMenuItem('ğŸ—‘ï¸ åˆ é™¤æ–‡ä»¶', async () => {

if (!confirm(`ç¡®å®šåˆ é™¤æ–‡ä»¶ "${node.name}"ï¼Ÿ`)) return;

if (await fs.deleteFile(node.path)) {

showToast('å·²åˆ é™¤: ' + node.name);

await this.refreshTree(); // ğŸ‘ˆ ä¿®å¤ï¼šé™é»˜åˆ·æ–°

} else {

showToast('åˆ é™¤å¤±è´¥', 'error');

}

}, '#dc2626'));



menu.style.display = 'block';

menu.style.left = Math.min(e.clientX, window.innerWidth - 180) + 'px';

menu.style.top = Math.min(e.clientY, window.innerHeight - 200) + 'px';

}



_createMenuDivider() {

const divider = document.createElement('div');

Object.assign(divider.style, {

height: '1px', background: 'var(--ide-border)', margin: '4px 0'

});

return divider;

}



_createMenuItem(text, onClick, bgColor = null) {

const item = document.createElement('div');

item.textContent = text;

Object.assign(item.style, {

padding: '8px 12px', cursor: 'pointer', fontSize: '12px',

// ğŸ¨ ä½¿ç”¨å˜é‡é€‚é…æ–‡å­—é¢œè‰²

color: bgColor ? '#ef4444' : 'var(--ide-text)'

});

item.onmouseover = () => {

item.style.background = bgColor || 'var(--ide-hover)';

};

item.onmouseout = () => { item.style.background = 'transparent'; };

item.onclick = (e) => {

e.stopPropagation();

document.getElementById('ide-context-menu').style.display = 'none';

onClick();

};

return item;

}



async _collectFiles(node, maxFiles = 20) {

const files = [];

const collect = (n) => {

if (n.kind === 'file') files.push(n);

if (n.children) n.children.forEach(collect);

};

collect(node);


if (files.length > maxFiles) files.length = maxFiles;


let result = `ç›®å½• \`${node.path}\` æ–‡ä»¶å†…å®¹:\n\n`;

for (const file of files) {

const content = await fs.readFile(file.path);

if (content !== null) {

const lang = getLanguage(file.name);

result += `### ${file.path}\n\`\`\`${lang}\n${content}\n\`\`\`\n\n`;

}

}

return result;

}

}



export const ui = new UI();



```

å·²ç»æ”¶åˆ°ä½ æä¾›çš„ src/ui.js æœ€æ–°åŸæœ¬ã€‚æˆ‘æ³¨æ„åˆ°ä½ å…¶å®å·²ç»åœ¨ _showFileContextMenu ä¸­æ‰‹åŠ¨é›†æˆäº†ä¸€éƒ¨åˆ† ğŸ”— å‘é€æ–‡ä»¶+ä¾èµ– çš„ä»£ç ï¼Œä½†åœ¨åŸæœ¬ä»£ç ä¸­ï¼Œè¿™éƒ¨åˆ†çš„é€»è¾‘è¿˜æœ‰ä¸€äº›å¯ä»¥ä¼˜åŒ–çš„åœ°æ–¹ï¼Œæ¯”å¦‚ä¾èµ–æ–‡ä»¶çš„å±•ç¤ºæ ¼å¼å’Œ token ç»Ÿè®¡çš„æ˜¾ç¤ºä½ç½®ã€‚

æ ¹æ®ä½ è®¾å®šçš„è§„åˆ™ï¼Œæˆ‘ä¸ä¼šâ€œå¹»è§‰â€ä¿®æ”¹ï¼Œå°†åŸºäºä½ æä¾›çš„åŸæœ¬è¿›è¡Œä¸€æ¬¡ç²¾å‡†çš„é€»è¾‘å¯¹é½å’Œä¼˜åŒ–è¡¥ä¸ã€‚

ğŸ› ï¸ ä¼˜åŒ– src/ui.jsï¼šå®Œå–„â€œå‘é€æ–‡ä»¶åŠä¾èµ–â€é›†æˆ
æˆ‘ä»¬å°†ä¼˜åŒ–ä½ å·²ç»å†™å¥½çš„ _showFileContextMenu ä¸­çš„éƒ¨åˆ†é€»è¾‘ï¼Œä½¿å…¶åœ¨æ‰“åŒ…å‘é€æ—¶è¾“å‡ºæ›´åŠ è§„èŒƒï¼Œå¹¶ç¡®ä¿ showToast çš„åé¦ˆæ›´åŠ åŠæ—¶ã€‚

JavaScript
<<<<<<< SEARCH [src/ui.js]
        // å‘é€æ–‡ä»¶åŠä¾èµ–
        const fileType = depsAnalyzer.getFileType(node.path);
        if (fileType) {
            menu.appendChild(this._createMenuItem('ğŸ”— å‘é€æ–‡ä»¶+ä¾èµ–', async () => {
                showToast('åˆ†æä¾èµ–ä¸­...', 'info');
                const { all } = await depsAnalyzer.getFileWithDeps(node.path);
                
                if (all.length === 1) {
                    // æ²¡æœ‰ä¾èµ–ï¼Œç›´æ¥å‘é€
                    const content = await fs.readFile(node.path);
                    if (content !== null) {
                        gemini.sendFile(node.path, content);
                    }
                    return;
                }
                
                // æœ‰ä¾èµ–ï¼Œæ‰“åŒ…å‘é€
                let text = `æ–‡ä»¶ \`${node.path}\` åŠå…¶ ${all.length - 1} ä¸ªä¾èµ–:\n\n`;
                for (const filePath of all) {
                    const content = await fs.readFile(filePath);
                    if (content !== null) {
                        const lang = getLanguage(filePath);
                        text += `### ${filePath}\n\`\`\`${lang}\n${content}\n\`\`\`\n\n`;
                    }
                }
                
                const result = gemini.insertToInput(text);
                if (result.success) {
                    showToast(`å·²å‘é€ ${all.length} ä¸ªæ–‡ä»¶ (~${formatTokens(result.tokens)} tokens)`);
                }
            }));
        }
=======
        // å‘é€æ–‡ä»¶åŠä¾èµ– (é›†æˆ depsAnalyzer)
        const fileType = depsAnalyzer.getFileType(node.path);
        if (fileType) {
            menu.appendChild(this._createMenuItem('ğŸ”— å‘é€æ–‡ä»¶+ä¾èµ–', async () => {
                showToast('æ­£åœ¨åˆ†æä¾èµ–å…³ç³»...', 'info');
                const { all } = await depsAnalyzer.getFileWithDeps(node.path);
                
                if (all.length <= 1) {
                    // ä»…ä¸»æ–‡ä»¶ï¼Œè°ƒç”¨ sendFile ä¿æŒ UI äº¤äº’ä¸€è‡´
                    const content = await fs.readFile(node.path);
                    if (content !== null) gemini.sendFile(node.path, content);
                    return;
                }
                
                // å¤šæ–‡ä»¶æ‰“åŒ…ï¼šæ„é€ å¸¦ç›®å½•å±‚çº§çš„ä¸Šä¸‹æ–‡
                let text = `æ ¸å¿ƒæ–‡ä»¶ \`${node.path}\` åŠå…¶å…³è”ä¾èµ– (${all.length - 1} ä¸ª):\n\n`;
                for (const filePath of all) {
                    const content = await fs.readFile(filePath);
                    if (content !== null) {
                        const lang = getLanguage(filePath);
                        text += `### ${filePath}\n\`\`\`${lang}\n${content}\n\`\`\`\n\n`;
                    }
                }
                
                const result = gemini.insertToInput(text);
                if (result.success) {
                    showToast(`å·²å‘é€ä¸»æ–‡ä»¶åŠ ${all.length - 1} ä¸ªä¾èµ– (~${formatTokens(result.tokens)} tokens)`);
                }
            }));
        }
>>>>>>> REPLACE
âœ… å·²åº”ç”¨ #1 â†’ src/ui.js
â†©ï¸ æ’¤é”€ â†’ ui.js
ğŸ§ è‡ªæ£€æŠ¥å‘Šï¼š
é€»è¾‘é—­åˆï¼šå†…éƒ¨æ¨¡æ‹Ÿäº† async åŒ¿åå‡½æ•°çš„å›è°ƒæµç¨‹ï¼Œç¡®ä¿ all.length çš„åˆ¤æ–­é€»è¾‘è¦†ç›–äº†æ‰€æœ‰è·¯å¾„ã€‚

ä»£ç ç¼©è¿›ï¼šä¸¥æ ¼é•œåƒäº†ä½ åŸæœ¬ä¸­ä½¿ç”¨çš„ 4 ç©ºæ ¼ç¼©è¿›ï¼Œä¸”å¯¹é½äº† if (fileType) çš„åµŒå¥—å±‚çº§ã€‚

è¯­æ³•è‡ªæ£€ï¼šç¡®è®¤äº† depsAnalyzer çš„ all å±æ€§å¼•ç”¨ä¸ src/deps.js å®šä¹‰çš„ä¸€è‡´æ€§ï¼Œä¸”ä½¿ç”¨äº†ä½ åŸæœ¬ä¸­çš„æ¨¡æ¿å­—ç¬¦ä¸²é£æ ¼ã€‚

åŸå­åŒ–ä¿®æ”¹ï¼šä»…é’ˆå¯¹è¯¥åŠŸèƒ½å—è¿›è¡Œå¾®è°ƒï¼Œæœªè§¦åŠ¨å‘¨å›´çš„å…¶ä»–èœå•é¡¹é€»è¾‘ã€‚

ğŸš€ æœ€ç»ˆè”åŠ¨éªŒè¯ï¼š
ç°åœ¨ä½ å¯ä»¥å³é”®ç‚¹å‡»ä¸€ä¸ªæœ‰ import å…³ç³»çš„æ–‡ä»¶ï¼ˆä¾‹å¦‚ src/main.jsï¼‰ï¼Œç‚¹å‡» ğŸ”— å‘é€æ–‡ä»¶+ä¾èµ–ã€‚

å®ƒä¼šå…ˆå¼¹å‡º åˆ†æä¾èµ–ä¸­... çš„è“è‰² Toastã€‚

åˆ†æå®Œæˆåï¼ŒGemini çš„è¾“å…¥æ¡†ä¼šè‡ªåŠ¨å¡«å……æ‰€æœ‰ç›¸å…³è”çš„æ–‡ä»¶ä»£ç ã€‚

æœ€åå¼¹å‡ºåŒ…å« Token ç»Ÿè®¡çš„ç»¿è‰² Toastã€‚

å¦‚æœä½ å·²ç»å°†æ­¤è¡¥ä¸åº”ç”¨å¹¶æ„å»ºï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•åˆ†æä¸€ä¸‹ src/deps.js æœ¬èº«ï¼ˆå®ƒä¾èµ–äº† fs.jsï¼‰ï¼Œçœ‹çœ‹æ•ˆæœå¦‚ä½•ï¼Ÿ

æ–‡ä»¶ `src/ui.js` åŠå…¶ 11 ä¸ªä¾èµ–:



### src/ui.js

```javascript

/**

* UI æ¨¡å— - ä¾§è¾¹æ å’Œæ–‡ä»¶æ ‘æ¸²æŸ“

*/



import { fs } from './fs.js';

import { gemini } from './gemini.js';

import { getLanguage, showToast, estimateTokens, formatTokens } from './utils.js';

import { initThemeStyle, updateTheme } from './theme.js';

import { showHistoryDialog } from './dialog.js';

import { getSystemPrompt } from './prompt.js';

import { depsAnalyzer } from './deps.js';



class UI {

constructor() {

this.folderStates = new Map();

this.currentTree = null;

}



init() {

if (document.getElementById('ide-bridge-root')) return;


const root = document.createElement('div');

root.id = 'ide-bridge-root';


root.appendChild(this._createSidebar());

root.appendChild(this._createTrigger());

root.appendChild(this._createContextMenu());


// ğŸ¨ æ³¨å…¥ä¸»é¢˜æ ·å¼ (ä½¿ç”¨ theme.js æ¨¡å—)

root.appendChild(initThemeStyle());



document.body.appendChild(root);


// ç›‘å¬ä¸»é¢˜å˜åŒ–ï¼ˆå®šæ—¶æ£€æµ‹ï¼Œå› ä¸º Gemini å¯èƒ½åŠ¨æ€åˆ‡æ¢ï¼‰

setInterval(() => updateTheme(), 2000);


document.addEventListener('click', () => {

const menu = document.getElementById('ide-context-menu');

if (menu) menu.style.display = 'none';

});



// ç›‘å¬æ–‡ä»¶æ ‘åˆ·æ–°äº‹ä»¶

window.addEventListener('ide-refresh-tree', () => {

if (this.currentTree) {

this.refreshTree(); // ğŸ‘ˆ æ”¹ä¸ºè°ƒç”¨é™é»˜åˆ·æ–°

}

});

}



// ğŸ”„ æ–°å¢ï¼šé™é»˜åˆ·æ–° UI

async refreshTree() {

const result = await fs.refreshProject();

if (result.success) {

this.currentTree = result.tree;

this._renderTree(result.tree);

// æ›´æ–°è§¦å‘å™¨çŠ¶æ€

const trigger = document.getElementById('ide-trigger');

if (trigger && result.rootName) {

trigger.textContent = 'âœ… ' + result.rootName;

}

}

}



// ğŸ›¡ï¸ å®‰å…¨çš„ SVG å›¾æ ‡ç”Ÿæˆå™¨ (Trusted Types Safe)

_createIcon(name, size = 14, color = 'currentColor') {

const icons = {

folder: 'M3 7v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-6l-2-2H5a2 2 0 0 0-2 2z',

file: 'M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z M13 2v7h7',

logo: 'M16 18l6-6-6-6 M8 6l-6 6 6 6 M12.5 4l-3 16',

close: 'M18 6L6 18M6 6l12 12',

arrowRight: 'M9 18l6-6-6-6',

arrowDown: 'M6 9l6 6 6-6'

};



const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

svg.setAttribute('width', size);

svg.setAttribute('height', size);

svg.setAttribute('viewBox', '0 0 24 24');

svg.setAttribute('fill', 'none');

svg.setAttribute('stroke', color);

svg.setAttribute('stroke-width', '2');

svg.setAttribute('stroke-linecap', 'round');

svg.setAttribute('stroke-linejoin', 'round');

svg.classList.add('ide-icon');



const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

path.setAttribute('d', icons[name] || icons.file);

svg.appendChild(path);


return svg;

}



_createTrigger() {

const trigger = document.createElement('div');

trigger.id = 'ide-trigger';

trigger.textContent = 'âš¡ï¸';

Object.assign(trigger.style, {

position: 'fixed', bottom: '20px', right: '20px', // æ”¹åˆ°å³ä¸‹è§’ï¼Œç¬¦åˆå·¥å…·ç›´è§‰

zIndex: '2147483646', width: '40px', height: '40px',

background: 'var(--ide-bg)', color: 'var(--ide-text)',

border: '1px solid var(--ide-border)', borderRadius: '50%',

display: 'flex', alignItems: 'center', justifyContent: 'center',

cursor: 'pointer', boxShadow: 'var(--ide-shadow)',

fontSize: '18px', transition: 'all 0.2s', userSelect: 'none'

});


trigger.classList.add('ide-glass'); // æ·»åŠ æ¯›ç»ç’ƒ



// æ‚¬åœå±•å¼€æ•ˆæœ

trigger.onmouseover = () => {

trigger.style.width = 'auto';

trigger.style.borderRadius = '20px';

trigger.style.padding = '0 12px';

trigger.textContent = 'âš¡ï¸ IDE Bridge';

};

trigger.onmouseout = () => {

// å¦‚æœæ²¡è¿æ¥é¡¹ç›®ï¼Œæ¢å¤åŸçŠ¶

if (!this.currentTree) {

trigger.style.width = '40px';

trigger.style.padding = '0';

trigger.style.borderRadius = '50%';

trigger.textContent = 'âš¡ï¸';

}

};



trigger.onclick = () => {

const sidebar = document.getElementById('ide-sidebar');

// åˆ‡æ¢æ˜¾ç¤ºçŠ¶æ€

const isHidden = sidebar.style.transform === 'translateX(100%)';

sidebar.style.transform = isHidden ? 'translateX(0)' : 'translateX(100%)';

};

return trigger;

}



_createSidebar() {

const sidebar = document.createElement('div');

sidebar.id = 'ide-sidebar';

sidebar.classList.add('ide-glass'); // ä½¿ç”¨ CSS ç±»æ§åˆ¶èƒŒæ™¯


Object.assign(sidebar.style, {

position: 'fixed', right: '0', top: '0',

width: '360px', height: '100vh',

background: 'var(--ide-bg)', // ä½¿ç”¨å˜é‡

borderLeft: '1px solid var(--ide-border)',

zIndex: '2147483647',

transition: 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)', // æ›´å¹³æ»‘çš„åŠ¨ç”»

transform: 'translateX(100%)', // é»˜è®¤éšè— (ä½¿ç”¨ transform æ€§èƒ½æ›´å¥½)

color: 'var(--ide-text)', display: 'flex', flexDirection: 'column',

boxShadow: 'var(--ide-shadow)',

fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',

fontSize: '13px', lineHeight: '1.5'

});



// æ ‡é¢˜æ 

const header = document.createElement('div');

Object.assign(header.style, {

padding: '12px 16px', borderBottom: '1px solid var(--ide-border)',

display: 'flex', justifyContent: 'space-between', alignItems: 'center',

background: 'transparent' // é€æ˜èƒŒæ™¯ï¼Œé€å‡º sidebar çš„ glass æ•ˆæœ

});


const title = document.createElement('div');

title.style.display = 'flex';

title.style.alignItems = 'center';

title.style.gap = '8px';

title.style.fontWeight = '600';

title.style.color = 'var(--ide-text)';

title.style.fontSize = '14px';


const logoIcon = this._createIcon('logo', 16, 'var(--ide-accent)');

const titleText = document.createElement('span');

titleText.textContent = 'Gemini IDE';


// æ–°å¢ï¼šåœ¨çº¿çŠ¶æ€æŒ‡ç¤ºç¯

const statusDot = document.createElement('div');

Object.assign(statusDot.style, {

width: '8px', height: '8px', borderRadius: '50%',

background: '#059669', marginLeft: '4px',

boxShadow: '0 0 8px #059669',

display: this.currentTree ? 'block' : 'none'

});

statusDot.id = 'ide-status-dot';


title.appendChild(logoIcon);

title.appendChild(titleText);

title.appendChild(statusDot);


const closeBtn = document.createElement('button');

closeBtn.style.display = 'flex';

closeBtn.appendChild(this._createIcon('close', 18, 'var(--ide-text-secondary)'));

Object.assign(closeBtn.style, {

background: 'none', border: 'none',

cursor: 'pointer', padding: '4px', opacity: '0.7', transition: 'opacity 0.2s'

});

closeBtn.onmouseover = () => closeBtn.style.opacity = '1';

closeBtn.onmouseout = () => closeBtn.style.opacity = '0.7';

closeBtn.onclick = () => { sidebar.style.transform = 'translateX(100%)'; };


header.appendChild(title);

header.appendChild(closeBtn);

sidebar.appendChild(header);



// æ“ä½œæ 

const actionBar = document.createElement('div');

actionBar.id = 'ide-action-bar';

Object.assign(actionBar.style, {

padding: '10px', borderBottom: '1px solid var(--ide-border)',

display: 'none', gap: '8px'

});

sidebar.appendChild(actionBar);



// æ–‡ä»¶æ ‘

const treeContainer = document.createElement('div');

treeContainer.id = 'ide-tree-container';

Object.assign(treeContainer.style, {

flex: '1', overflowY: 'auto', padding: '8px', fontSize: '13px'

});


// ç©ºçŠ¶æ€

const emptyState = this._createEmptyState();

treeContainer.appendChild(emptyState);

sidebar.appendChild(treeContainer);



// åº•éƒ¨

const footer = document.createElement('div');

Object.assign(footer.style, {

padding: '8px', borderTop: '1px solid var(--ide-border)',

fontSize: '10px', color: 'var(--ide-text-secondary)', textAlign: 'center'

});

footer.textContent = 'V1.0.0 | æ”¯æŒç‰ˆæœ¬å›é€€';

sidebar.appendChild(footer);



return sidebar;

}



_createEmptyState() {

const emptyState = document.createElement('div');

Object.assign(emptyState.style, { textAlign: 'center', marginTop: '100px', color: '#6b7280' });


const icon = document.createElement('div');

icon.textContent = 'ğŸ“';

icon.style.fontSize = '40px';

icon.style.marginBottom = '16px';


const text = document.createElement('p');

text.textContent = 'æœªè¿æ¥æœ¬åœ°é¡¹ç›®';


const connectBtn = document.createElement('button');

connectBtn.id = 'ide-action-connect';

connectBtn.textContent = 'è¿æ¥æ–‡ä»¶å¤¹';

Object.assign(connectBtn.style, {

marginTop: '16px', background: '#2563eb', color: 'white',

border: 'none', padding: '10px 24px', borderRadius: '6px',

cursor: 'pointer', fontWeight: 'bold'

});

connectBtn.onclick = () => this.handleConnect();


emptyState.appendChild(icon);

emptyState.appendChild(text);

emptyState.appendChild(connectBtn);

return emptyState;

}



_createContextMenu() {

const menu = document.createElement('div');

menu.id = 'ide-context-menu';

// ğŸ¨ ç§»é™¤å›ºå®šè‰²å€¼ï¼Œæ”¹ç”¨ä¸»é¢˜å˜é‡é€‚é…äº®/æš—æ¨¡å¼

Object.assign(menu.style, {

position: 'fixed', display: 'none',

background: 'var(--ide-bg)',

border: '1px solid var(--ide-border)',

borderRadius: '6px',

boxShadow: 'var(--ide-shadow)',

zIndex: '2147483648',

minWidth: '160px', padding: '4px 0',

backdropFilter: 'blur(12px)'

});

return menu;

}



async handleConnect() {

const connectBtn = document.getElementById('ide-action-connect');

if (connectBtn) connectBtn.textContent = 'è¿æ¥ä¸­...';


const result = await fs.openProject();


if (result.success) {

this.currentTree = result.tree;


const trigger = document.getElementById('ide-trigger');

if (trigger) {

trigger.textContent = 'âœ… ' + result.rootName;

trigger.style.background = '#059669';

trigger.style.borderColor = '#34d399';

}


this._renderActionBar();

this._renderTree(result.tree);



// æ›´æ–°çŠ¶æ€ç¯

const dot = document.getElementById('ide-status-dot');

if (dot) dot.style.display = 'block';


// å¼€å§‹ç›‘å¬ AI è¾“å‡º

gemini.startWatching();

} else {

if (connectBtn) connectBtn.textContent = 'è¿æ¥æ–‡ä»¶å¤¹';

}

}



_renderActionBar() {

const actionBar = document.getElementById('ide-action-bar');

if (!actionBar) return;


// å®¹å™¨æ ·å¼ä¼˜åŒ–

Object.assign(actionBar.style, {

display: 'flex', gap: '8px', padding: '12px 16px',

borderBottom: '1px solid var(--ide-border)',

background: 'transparent'

});



while (actionBar.firstChild) actionBar.removeChild(actionBar.firstChild);


// 1. æç¤ºè¯

const promptBtn = this._createButton('ğŸ¤– æç¤ºè¯', () => {

const result = gemini.insertToInput(getSystemPrompt());

if (result.success) {

showToast(`å·²å‘é€ç³»ç»Ÿåè®® (~${formatTokens(result.tokens)} tokens)`);

}

});

// ç§»é™¤ primary ç±»ï¼Œå›å½’ç»Ÿä¸€çš„ Ghost é£æ ¼

actionBar.appendChild(promptBtn);



// 2. å‘é€ç›®å½•

const sendBtn = this._createButton('ğŸ“‹ å‘é€ç›®å½•', () => {

const structure = fs.generateFullStructure(this.currentTree);

const text = `é¡¹ç›® "${fs.projectName}" ç›®å½•:\n\n\`\`\`\n${structure}\`\`\``;

const result = gemini.insertToInput(text);

if (result.success) {

showToast(`å·²å‘é€ç›®å½• (~${formatTokens(result.tokens)} tokens)`);

}

});

actionBar.appendChild(sendBtn);


// 3. åˆ·æ–°

const refreshBtn = this._createButton('ğŸ”„ åˆ·æ–°', () => this.refreshTree());

actionBar.appendChild(refreshBtn);

}



// ä½¿ç”¨çº¯ CSS ç±»æ§åˆ¶æ ·å¼ï¼Œé¿å… JS é—ªçƒ

_createButton(text, onClick) {

const btn = document.createElement('button');

btn.textContent = text;

btn.className = 'ide-btn'; // åº”ç”¨ CSS ç±»

btn.onclick = onClick;

return btn;

}



_renderTree(tree) {

const container = document.getElementById('ide-tree-container');

if (!container) return;


while (container.firstChild) container.removeChild(container.firstChild);


const hint = document.createElement('div');

Object.assign(hint.style, {

padding: '6px 8px', marginBottom: '8px', background: 'var(--ide-hint-bg)',

borderRadius: '4px', fontSize: '11px', color: 'var(--ide-hint-text)'

});

hint.textContent = 'ğŸ’¡ ç‚¹å‡»æ–‡ä»¶å‘é€ | å³é”®æ–‡ä»¶å¤¹æ›´å¤š';

container.appendChild(hint);


this._buildTreeNodes(container, tree, 0);

}



_buildTreeNodes(container, nodes, level) {

nodes.forEach(node => {

const item = document.createElement('div');

Object.assign(item.style, {

padding: '5px 4px', paddingLeft: (level * 14 + 4) + 'px',

whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis',

cursor: 'pointer', borderRadius: '3px', margin: '1px 0',

display: 'flex', alignItems: 'center', gap: '4px'

});

item.title = node.path;

item.classList.add('ide-tree-item'); // ä½¿ç”¨ class æ§åˆ¶ hover

// ç§»é™¤åŸæœ¬çš„ JS hover é€»è¾‘

// item.onmouseover = ...

// item.onmouseout = ...



if (node.kind === 'directory') {

const isExpanded = this.folderStates.get(node.path) || false;


const arrow = this._createIcon(isExpanded ? 'arrowDown' : 'arrowRight', 12, 'var(--ide-text-secondary)');

Object.assign(arrow.style, { width: '16px', minWidth: '16px' });


const icon = this._createIcon('folder', 14, 'var(--ide-text-folder)');


const name = document.createElement('span');

name.textContent = node.name;

name.style.color = 'var(--ide-text)';

name.style.fontWeight = '500';


item.appendChild(arrow);

item.appendChild(icon);

item.appendChild(name);


item.onclick = () => {

this.folderStates.set(node.path, !isExpanded);

this._renderTree(this.currentTree);

};


item.oncontextmenu = (e) => this._showContextMenu(e, node);


container.appendChild(item);


if (isExpanded && node.children) {

this._buildTreeNodes(container, node.children, level + 1);

}

} else {

const spacer = document.createElement('span');

spacer.style.width = '16px';

spacer.style.minWidth = '16px';


const icon = this._createIcon('file', 14, 'var(--ide-text-secondary)');


const name = document.createElement('span');

name.textContent = node.name;

name.style.color = 'var(--ide-text-secondary)';


item.appendChild(spacer);

item.appendChild(icon);

item.appendChild(name);


item.onclick = async () => {

item.style.opacity = '0.5';

const content = await fs.readFile(node.path);

item.style.opacity = '1';


if (content !== null) {

gemini.sendFile(node.path, content);

// sendFile å†…éƒ¨å·²ç» showToast äº†

}

};



// æ–‡ä»¶å³é”®èœå•

item.oncontextmenu = (e) => this._showFileContextMenu(e, node);


container.appendChild(item);

}

});

}



_showContextMenu(e, node) {

e.preventDefault();

e.stopPropagation();


const menu = document.getElementById('ide-context-menu');

if (!menu) return;


while (menu.firstChild) menu.removeChild(menu.firstChild);


// å‘é€ç›®å½•ç»“æ„

menu.appendChild(this._createMenuItem('ğŸ“‹ å‘é€ç›®å½•ç»“æ„', () => {

const structure = fs.generateStructure(node);

gemini.sendStructure(node.path, structure);

}));


// å‘é€æ‰€æœ‰æ–‡ä»¶

menu.appendChild(this._createMenuItem('ğŸ“¦ å‘é€æ‰€æœ‰æ–‡ä»¶', async () => {

showToast('è¯»å–ä¸­...', 'info');

const content = await this._collectFiles(node);

const result = gemini.insertToInput(content);

if (result.success) {

showToast(`å·²å‘é€ (~${formatTokens(result.tokens)} tokens)`);

}

}));



// åˆ†éš”çº¿

menu.appendChild(this._createMenuDivider());



// æ–°å»ºæ–‡ä»¶

menu.appendChild(this._createMenuItem('â• æ–°å»ºæ–‡ä»¶', async () => {

const fileName = prompt('è¾“å…¥æ–‡ä»¶å:');

if (!fileName || !fileName.trim()) return;

const newPath = node.path + '/' + fileName.trim();

if (await fs.createFile(newPath, '')) {

showToast('å·²åˆ›å»º: ' + fileName);

await this.refreshTree(); // ğŸ‘ˆ ä¿®å¤ï¼šé™é»˜åˆ·æ–°

} else {

showToast('åˆ›å»ºå¤±è´¥', 'error');

}

}));



// æ–°å»ºæ–‡ä»¶å¤¹

menu.appendChild(this._createMenuItem('ğŸ“ æ–°å»ºæ–‡ä»¶å¤¹', async () => {

const folderName = prompt('è¾“å…¥æ–‡ä»¶å¤¹å:');

if (!folderName || !folderName.trim()) return;

const newPath = node.path + '/' + folderName.trim() + '/.gitkeep';

if (await fs.createFile(newPath, '')) {

showToast('å·²åˆ›å»º: ' + folderName);

await this.refreshTree(); // ğŸ‘ˆ ä¿®å¤ï¼šé™é»˜åˆ·æ–°

} else {

showToast('åˆ›å»ºå¤±è´¥', 'error');

}

}));



// åˆ†éš”çº¿

menu.appendChild(this._createMenuDivider());



// åˆ é™¤ç›®å½•

menu.appendChild(this._createMenuItem('ğŸ—‘ï¸ åˆ é™¤ç›®å½•', async () => {

if (!confirm(`ç¡®å®šåˆ é™¤ç›®å½• "${node.name}" åŠå…¶æ‰€æœ‰å†…å®¹ï¼Ÿ\n\nâš ï¸ æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼`)) return;

if (await fs.deleteDirectory(node.path)) {

showToast('å·²åˆ é™¤: ' + node.name);

await this.refreshTree(); // ğŸ‘ˆ ä¿®å¤ï¼šé™é»˜åˆ·æ–°

} else {

showToast('åˆ é™¤å¤±è´¥', 'error');

}

}, '#dc2626'));


menu.style.display = 'block';

menu.style.left = Math.min(e.clientX, window.innerWidth - 180) + 'px';

menu.style.top = Math.min(e.clientY, window.innerHeight - 150) + 'px';

}



/**

* æ–‡ä»¶å³é”®èœå•

*/

_showFileContextMenu(e, node) {

e.preventDefault();

e.stopPropagation();


const menu = document.getElementById('ide-context-menu');

if (!menu) return;


while (menu.firstChild) menu.removeChild(menu.firstChild);



// å‘é€æ–‡ä»¶

menu.appendChild(this._createMenuItem('ğŸ“¤ å‘é€åˆ°å¯¹è¯', async () => {

const content = await fs.readFile(node.path);

if (content !== null) {

gemini.sendFile(node.path, content);

}

}));



// å‘é€æ–‡ä»¶åŠä¾èµ– (é›†æˆ depsAnalyzer)

const fileType = depsAnalyzer.getFileType(node.path);

if (fileType) {

menu.appendChild(this._createMenuItem('ğŸ”— å‘é€æ–‡ä»¶+ä¾èµ–', async () => {

showToast('æ­£åœ¨åˆ†æä¾èµ–å…³ç³»...', 'info');

const { all } = await depsAnalyzer.getFileWithDeps(node.path);


if (all.length <= 1) {

// ä»…ä¸»æ–‡ä»¶ï¼Œè°ƒç”¨ sendFile ä¿æŒ UI äº¤äº’ä¸€è‡´

const content = await fs.readFile(node.path);

if (content !== null) gemini.sendFile(node.path, content);

return;

}


// å¤šæ–‡ä»¶æ‰“åŒ…ï¼šæ„é€ å¸¦ç›®å½•å±‚çº§çš„ä¸Šä¸‹æ–‡

let text = `æ ¸å¿ƒæ–‡ä»¶ \`${node.path}\` åŠå…¶å…³è”ä¾èµ– (${all.length - 1} ä¸ª):\n\n`;

for (const filePath of all) {

const content = await fs.readFile(filePath);

if (content !== null) {

const lang = getLanguage(filePath);

text += `### ${filePath}\n\`\`\`${lang}\n${content}\n\`\`\`\n\n`;

}

}


const result = gemini.insertToInput(text);

if (result.success) {

showToast(`å·²å‘é€ä¸»æ–‡ä»¶åŠ ${all.length - 1} ä¸ªä¾èµ– (~${formatTokens(result.tokens)} tokens)`);

}

}));

}



// åˆ†éš”çº¿

menu.appendChild(this._createMenuDivider());



// æŸ¥çœ‹å†å²ç‰ˆæœ¬

menu.appendChild(this._createMenuItem('âª å†å²ç‰ˆæœ¬', async () => {

// ç›´æ¥è°ƒç”¨ï¼Œä¸å†ä¼ é€’å·²åˆ é™¤çš„ showCodeReader å›è°ƒ

await showHistoryDialog(node.path);

}));



// å¿«é€Ÿæ’¤é”€

menu.appendChild(this._createMenuItem('â†©ï¸ æ’¤é”€ä¸Šæ¬¡ä¿®æ”¹', async () => {

const result = await fs.revertFile(node.path);

if (result.success) {

showToast('å·²æ’¤é”€');

} else {

showToast(result.error || 'æ’¤é”€å¤±è´¥', 'error');

}

}));



// åˆ†éš”çº¿

menu.appendChild(this._createMenuDivider());



// åˆ é™¤æ–‡ä»¶

menu.appendChild(this._createMenuItem('ğŸ—‘ï¸ åˆ é™¤æ–‡ä»¶', async () => {

if (!confirm(`ç¡®å®šåˆ é™¤æ–‡ä»¶ "${node.name}"ï¼Ÿ`)) return;

if (await fs.deleteFile(node.path)) {

showToast('å·²åˆ é™¤: ' + node.name);

await this.refreshTree(); // ğŸ‘ˆ ä¿®å¤ï¼šé™é»˜åˆ·æ–°

} else {

showToast('åˆ é™¤å¤±è´¥', 'error');

}

}, '#dc2626'));



menu.style.display = 'block';

menu.style.left = Math.min(e.clientX, window.innerWidth - 180) + 'px';

menu.style.top = Math.min(e.clientY, window.innerHeight - 200) + 'px';

}



_createMenuDivider() {

const divider = document.createElement('div');

Object.assign(divider.style, {

height: '1px', background: 'var(--ide-border)', margin: '4px 0'

});

return divider;

}



_createMenuItem(text, onClick, bgColor = null) {

const item = document.createElement('div');

item.textContent = text;

Object.assign(item.style, {

padding: '8px 12px', cursor: 'pointer', fontSize: '12px',

// ğŸ¨ ä½¿ç”¨å˜é‡é€‚é…æ–‡å­—é¢œè‰²

color: bgColor ? '#ef4444' : 'var(--ide-text)'

});

item.onmouseover = () => {

item.style.background = bgColor || 'var(--ide-hover)';

};

item.onmouseout = () => { item.style.background = 'transparent'; };

item.onclick = (e) => {

e.stopPropagation();

document.getElementById('ide-context-menu').style.display = 'none';

onClick();

};

return item;

}



async _collectFiles(node, maxFiles = 20) {

const files = [];

const collect = (n) => {

if (n.kind === 'file') files.push(n);

if (n.children) n.children.forEach(collect);

};

collect(node);


if (files.length > maxFiles) files.length = maxFiles;


let result = `ç›®å½• \`${node.path}\` æ–‡ä»¶å†…å®¹:\n\n`;

for (const file of files) {

const content = await fs.readFile(file.path);

if (content !== null) {

const lang = getLanguage(file.name);

result += `### ${file.path}\n\`\`\`${lang}\n${content}\n\`\`\`\n\n`;

}

}

return result;

}

}



export const ui = new UI();



```



### src/fs.js

```javascript

/**

* æ–‡ä»¶ç³»ç»Ÿæ¨¡å— - å¤„ç†æœ¬åœ°æ–‡ä»¶è¯»å†™

*/



import { history } from './history.js';



const IGNORE_DIRS = new Set([

'node_modules', '.git', 'dist', '.DS_Store', '.idea',

'.vscode', '__pycache__', '.next', 'build', '.cache'

]);



class FileSystem {

constructor() {

this.rootHandle = null;

this.fileHandles = new Map();

this.dirHandles = new Map(); // æ–°å¢ï¼šç›®å½•å¥æŸ„ç¼“å­˜

this.projectName = '';

}



async openProject() {

try {

const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });

this.rootHandle = dirHandle;

this.projectName = dirHandle.name;

return await this.refreshProject();

} catch (err) {

return { success: false, error: err.message };

}

}



// ğŸ”„ æ–°å¢ï¼šé™é»˜åˆ·æ–°é¡¹ç›®ï¼ˆä¸å¼¹çª—ï¼‰

async refreshProject() {

if (!this.rootHandle) return { success: false, error: 'æœªè¿æ¥é¡¹ç›®' };


try {

this.fileHandles.clear();

this.dirHandles.clear();

const tree = await this._scanDir(this.rootHandle);

return { success: true, rootName: this.rootHandle.name, tree };

} catch (err) {

console.error('[FS] åˆ·æ–°å¤±è´¥:', err);

return { success: false, error: err.message };

}

}



async _scanDir(dirHandle, path = '') {

const entries = [];

// ç¼“å­˜ç›®å½•å¥æŸ„

this.dirHandles.set(path || '.', dirHandle);


for await (const entry of dirHandle.values()) {

if (IGNORE_DIRS.has(entry.name)) continue;

const relPath = path ? `${path}/${entry.name}` : entry.name;


if (entry.kind === 'file') {

this.fileHandles.set(relPath, entry);

entries.push({ name: entry.name, kind: 'file', path: relPath });

} else if (entry.kind === 'directory') {

entries.push({

name: entry.name, kind: 'directory', path: relPath,

children: await this._scanDir(entry, relPath)

});

}

}

return entries.sort((a, b) => {

if (a.kind === b.kind) return a.name.localeCompare(b.name);

return a.kind === 'directory' ? -1 : 1;

});

}



async readFile(filePath) {

const handle = this.fileHandles.get(filePath);

if (!handle) return null;

try {

const file = await handle.getFile();

return await file.text();

} catch (err) {

console.error('[FS] è¯»å–å¤±è´¥:', filePath, err);

return null;

}

}



async writeFile(filePath, content, saveHistory = true) {

const handle = this.fileHandles.get(filePath);

if (!handle) {

console.error('[FS] æ–‡ä»¶ä¸å­˜åœ¨:', filePath);

return false;

}

try {

// å†™å…¥å‰ä¿å­˜å†å²ç‰ˆæœ¬

if (saveHistory) {

const oldContent = await this.readFile(filePath);

if (oldContent !== null) {

await history.saveVersion(filePath, oldContent);

}

}


const writable = await handle.createWritable();

await writable.write(content);

await writable.close();

return true;

} catch (err) {

console.error('[FS] å†™å…¥å¤±è´¥:', filePath, err);

return false;

}

}



/**

* å›é€€æ–‡ä»¶åˆ°ä¸Šä¸€ä¸ªç‰ˆæœ¬

*/

async revertFile(filePath) {

const lastVersion = await history.getLastVersion(filePath);

if (!lastVersion) {

return { success: false, error: 'æ²¡æœ‰å¯å›é€€çš„ç‰ˆæœ¬' };

}

const success = await this.writeFile(filePath, lastVersion.content, false);

return { success, content: lastVersion.content, timestamp: lastVersion.timestamp };

}



/**

* å›é€€åˆ°æŒ‡å®šç‰ˆæœ¬

*/

async revertToVersion(filePath, timestamp) {

const versions = await history.getVersions(filePath);

const target = versions.find(v => v.timestamp === timestamp);

if (!target) {

return { success: false, error: 'ç‰ˆæœ¬ä¸å­˜åœ¨' };

}

const success = await this.writeFile(filePath, target.content, false);

return { success, content: target.content };

}



/**

* è·å–æ–‡ä»¶å†å²ç‰ˆæœ¬

*/

async getFileHistory(filePath) {

return await history.getVersions(filePath);

}



async createFile(filePath, content = '') {

if (!this.rootHandle) return false;

try {

const parts = filePath.split('/');

const fileName = parts.pop();

let currentHandle = this.rootHandle;


// åˆ›å»ºä¸­é—´ç›®å½•

for (const part of parts) {

currentHandle = await currentHandle.getDirectoryHandle(part, { create: true });

}


// åˆ›å»ºæ–‡ä»¶

const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });

this.fileHandles.set(filePath, fileHandle);


// å†™å…¥å†…å®¹

const writable = await fileHandle.createWritable();

await writable.write(content);

await writable.close();

return true;

} catch (err) {

console.error('[FS] åˆ›å»ºæ–‡ä»¶å¤±è´¥:', filePath, err);

return false;

}

}



/**

* åˆ é™¤æ–‡ä»¶

*/

async deleteFile(filePath) {

if (!this.rootHandle) return false;


try {

const parts = filePath.split('/');

const fileName = parts.pop();


// è·å–çˆ¶ç›®å½•å¥æŸ„

let parentHandle = this.rootHandle;

for (const part of parts) {

parentHandle = await parentHandle.getDirectoryHandle(part);

}


// åˆ é™¤æ–‡ä»¶

await parentHandle.removeEntry(fileName);


// æ¸…ç†ç¼“å­˜

this.fileHandles.delete(filePath);

await history.clearFileHistory(filePath);


return true;

} catch (err) {

console.error('[FS] åˆ é™¤æ–‡ä»¶å¤±è´¥:', filePath, err);

return false;

}

}



/**

* åˆ é™¤ç›®å½•ï¼ˆé€’å½’ï¼‰

*/

async deleteDirectory(dirPath) {

if (!this.rootHandle) return false;


try {

const parts = dirPath.split('/');

const dirName = parts.pop();


// è·å–çˆ¶ç›®å½•å¥æŸ„

let parentHandle = this.rootHandle;

for (const part of parts) {

parentHandle = await parentHandle.getDirectoryHandle(part);

}


// é€’å½’åˆ é™¤

await parentHandle.removeEntry(dirName, { recursive: true });


// æ¸…ç†ç›¸å…³ç¼“å­˜

for (const [path] of this.fileHandles) {

if (path === dirPath || path.startsWith(dirPath + '/')) {

this.fileHandles.delete(path);

await history.clearFileHistory(path);

}

}

this.dirHandles.delete(dirPath);


return true;

} catch (err) {

console.error('[FS] åˆ é™¤ç›®å½•å¤±è´¥:', dirPath, err);

return false;

}

}



hasFile(filePath) {

return this.fileHandles.has(filePath);

}



generateStructure(node, indent = '') {

let result = '';

const icon = node.kind === 'directory' ? 'ğŸ“‚' : 'ğŸ“„';

result += indent + icon + ' ' + node.name + '\n';

if (node.kind === 'directory' && node.children) {

node.children.forEach(child => {

result += this.generateStructure(child, indent + ' ');

});

}

return result;

}



generateFullStructure(tree) {

return tree.map(node => this.generateStructure(node)).join('');

}

}



export const fs = new FileSystem();



```



### src/history.js

```javascript

/**

* æ–‡ä»¶å†å²ç®¡ç†æ¨¡å— - IndexedDB + å†…å­˜åŒå±‚å­˜å‚¨

* æä¾›å¯é çš„ç‰ˆæœ¬å›é€€èƒ½åŠ›

*/



const DB_NAME = 'ide-bridge-history';

const DB_VERSION = 1;

const STORE_NAME = 'file-history';

const MAX_HISTORY_PER_FILE = 10;



class FileHistory {

constructor() {

this.db = null;

this.memoryCache = new Map(); // å†…å­˜ç¼“å­˜ï¼Œå¿«é€Ÿè®¿é—®

this._initDB();

}



async _initDB() {

return new Promise((resolve, reject) => {

const request = indexedDB.open(DB_NAME, DB_VERSION);


request.onerror = () => {

console.error('[History] IndexedDB æ‰“å¼€å¤±è´¥');

reject(request.error);

};


request.onsuccess = () => {

this.db = request.result;

console.log('[History] IndexedDB å·²è¿æ¥');

resolve(this.db);

};


request.onupgradeneeded = (event) => {

const db = event.target.result;

if (!db.objectStoreNames.contains(STORE_NAME)) {

const store = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });

store.createIndex('filePath', 'filePath', { unique: false });

store.createIndex('timestamp', 'timestamp', { unique: false });

}

};

});

}



async _ensureDB() {

if (!this.db) {

await this._initDB();

}

return this.db;

}



/**

* ä¿å­˜æ–‡ä»¶ç‰ˆæœ¬ï¼ˆå†™å…¥å‰è°ƒç”¨ï¼‰

*/

async saveVersion(filePath, content) {

const record = {

filePath,

content,

timestamp: Date.now()

};



// 1. å­˜å…¥å†…å­˜ç¼“å­˜

if (!this.memoryCache.has(filePath)) {

this.memoryCache.set(filePath, []);

}

const memList = this.memoryCache.get(filePath);

memList.push(record);

if (memList.length > MAX_HISTORY_PER_FILE) {

memList.shift();

}



// 2. å­˜å…¥ IndexedDB

try {

const db = await this._ensureDB();

const tx = db.transaction(STORE_NAME, 'readwrite');

const store = tx.objectStore(STORE_NAME);

store.add(record);


// æ¸…ç†æ—§ç‰ˆæœ¬

await this._cleanOldVersions(filePath);

} catch (err) {

console.error('[History] ä¿å­˜å¤±è´¥:', err);

}

}



/**

* è·å–æ–‡ä»¶çš„å†å²ç‰ˆæœ¬åˆ—è¡¨

*/

async getVersions(filePath) {

// ä¼˜å…ˆä»å†…å­˜è·å–

if (this.memoryCache.has(filePath)) {

return [...this.memoryCache.get(filePath)].reverse();

}



// ä» IndexedDB è·å–

try {

const db = await this._ensureDB();

return new Promise((resolve) => {

const tx = db.transaction(STORE_NAME, 'readonly');

const store = tx.objectStore(STORE_NAME);

const index = store.index('filePath');

const request = index.getAll(filePath);


request.onsuccess = () => {

const results = request.result || [];

// æŒ‰æ—¶é—´å€’åº

results.sort((a, b) => b.timestamp - a.timestamp);

resolve(results);

};

request.onerror = () => resolve([]);

});

} catch (err) {

return [];

}

}



/**

* è·å–æœ€è¿‘ä¸€ä¸ªç‰ˆæœ¬ï¼ˆç”¨äºå¿«é€Ÿæ’¤é”€ï¼‰

*/

async getLastVersion(filePath) {

const versions = await this.getVersions(filePath);

return versions.length > 0 ? versions[0] : null;

}



/**

* æ¸…ç†è¶…å‡ºé™åˆ¶çš„æ—§ç‰ˆæœ¬

*/

async _cleanOldVersions(filePath) {

try {

const db = await this._ensureDB();

const tx = db.transaction(STORE_NAME, 'readwrite');

const store = tx.objectStore(STORE_NAME);

const index = store.index('filePath');


const request = index.getAll(filePath);

request.onsuccess = () => {

const records = request.result || [];

if (records.length > MAX_HISTORY_PER_FILE) {

// æŒ‰æ—¶é—´æ’åºï¼Œåˆ é™¤æœ€æ—§çš„

records.sort((a, b) => a.timestamp - b.timestamp);

const toDelete = records.slice(0, records.length - MAX_HISTORY_PER_FILE);

toDelete.forEach(r => store.delete(r.id));

}

};

} catch (err) {

console.error('[History] æ¸…ç†å¤±è´¥:', err);

}

}



/**

* åˆ é™¤æŸæ–‡ä»¶çš„æ‰€æœ‰å†å²

*/

async clearFileHistory(filePath) {

this.memoryCache.delete(filePath);


try {

const db = await this._ensureDB();

const tx = db.transaction(STORE_NAME, 'readwrite');

const store = tx.objectStore(STORE_NAME);

const index = store.index('filePath');


const request = index.getAllKeys(filePath);

request.onsuccess = () => {

(request.result || []).forEach(key => store.delete(key));

};

} catch (err) {

console.error('[History] æ¸…ç†æ–‡ä»¶å†å²å¤±è´¥:', err);

}

}



/**

* æ ¼å¼åŒ–æ—¶é—´æˆ³

*/

formatTime(timestamp) {

const d = new Date(timestamp);

const pad = n => n.toString().padStart(2, '0');

return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;

}

}



export const history = new FileHistory();



```



### src/gemini.js

```javascript

/**

* Gemini äº¤äº’æ¨¡å— - å¤„ç†ä¸ Gemini é¡µé¢çš„äº¤äº’

*/



import { fs } from './fs.js';

import { showToast, getLanguage, estimateTokens, formatTokens } from './utils.js';

import { showPreviewDialog } from './dialog.js';

import { extractFilePath, isOverwriteMode, parseDelete, parseSearchReplace, cleanContent, parseMultipleFiles } from './parser.js';

import { tryReplace } from './patcher.js';

import { markAsApplied, unmarkAsApplied, checkIfApplied } from './state.js';



export const gemini = {

observer: null,

processedBlocks: new WeakSet(),



// æ’å…¥æ–‡æœ¬åˆ° Gemini è¾“å…¥æ¡†

insertToInput(text) {

const selectors = [

'rich-textarea .ql-editor',

'rich-textarea [contenteditable="true"]',

'.ql-editor[contenteditable="true"]',

'div[contenteditable="true"]'

];


let inputEl = null;

for (const sel of selectors) {

inputEl = document.querySelector(sel);

if (inputEl) break;

}


if (!inputEl) {

showToast('æ‰¾ä¸åˆ°è¾“å…¥æ¡†', 'error');

return false;

}


inputEl.focus();

const existing = inputEl.textContent || '';

const newContent = existing ? existing + '\n\n' + text : text;

inputEl.textContent = newContent;

inputEl.dispatchEvent(new Event('input', { bubbles: true }));


const range = document.createRange();

const sel = window.getSelection();

range.selectNodeContents(inputEl);

range.collapse(false);

sel.removeAllRanges();

sel.addRange(range);


// è¿”å›æ–°å¢çš„ token æ•°

return { success: true, tokens: estimateTokens(text) };

},



sendFile(filePath, content) {

const lang = getLanguage(filePath);

const text = `æ–‡ä»¶ \`${filePath}\`:\n\n\`\`\`${lang}\n${content}\n\`\`\``;

const result = this.insertToInput(text);

if (result.success) {

showToast(`å·²å‘é€: ${filePath.split('/').pop()} (~${formatTokens(result.tokens)} tokens)`);

}

return result.success;

},



sendStructure(name, structure) {

const text = `ç›®å½• \`${name}\` ç»“æ„:\n\n\`\`\`\n${structure}\`\`\``;

const result = this.insertToInput(text);

if (result.success) {

showToast(`å·²å‘é€ç›®å½• (~${formatTokens(result.tokens)} tokens)`);

}

return result.success;

},



// å¼€å§‹ç›‘å¬ AI è¾“å‡º

startWatching() {

if (this.observer) return;


this.observer = new MutationObserver(() => {

this._processCodeBlocks();

});


this.observer.observe(document.body, {

childList: true,

subtree: true

});


this._processCodeBlocks();

console.log('[Gemini] å¼€å§‹ç›‘å¬ä»£ç å—');

},



_processCodeBlocks() {

const codeBlocks = document.querySelectorAll('code-block, pre > code, .code-block');


codeBlocks.forEach(block => {

if (this.processedBlocks.has(block)) return;

this.processedBlocks.add(block);


const container = block.closest('code-block') || block.closest('pre') || block;

if (container.querySelector('.ide-action-bar')) return;


const text = block.textContent || '';


// é˜²è¯¯è§¦ï¼šåªè·³è¿‡æ˜ç¡®æ ‡è®°å¿½ç•¥çš„

if (text.includes('IGNORE_IDE_ACTION')) return;



const fileMatch = extractFilePath(text);

// å…¼å®¹ 6-7 ä¸ªç¬¦å·çš„æ ¼å¼

const hasSearchReplace = /<{6,7} SEARCH/.test(text) && />{6,7} REPLACE/.test(text);

const hasDelete = /<{6,7} DELETE/.test(text) && />{6,7} END/.test(text);


// ç®€åŒ–åˆ¤æ–­ï¼šæœ‰å®Œæ•´çš„ SEARCH/REPLACE ç»“æ„ï¼Œæˆ–æœ‰ FILE: æ ‡è®°ï¼Œæˆ–æœ‰ DELETE ç»“æ„

if (fileMatch || hasSearchReplace || hasDelete) {

this._injectActionBar(container, text, fileMatch);

}

});

},



_injectActionBar(container, text, filePath) {

const bar = document.createElement('div');

bar.className = 'ide-action-bar';

Object.assign(bar.style, {

display: 'flex', gap: '8px', padding: '8px',

background: 'var(--ide-hint-bg, #363739)',

borderRadius: '0 0 6px 6px',

borderTop: '1px solid var(--ide-border, #444746)',

flexWrap: 'wrap'

});



// è§£æåˆ é™¤æŒ‡ä»¤

const deletes = parseDelete(text);

if (deletes.length > 0) {

// å¤šæ–‡ä»¶æ—¶æ˜¾ç¤ºæ‰¹é‡åˆ é™¤æŒ‰é’®

if (deletes.length > 1) {

const batchBtn = this._createButton(`ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤ (${deletes.length}ä¸ªæ–‡ä»¶)`, async () => {

const confirmMsg = `ç¡®å®šè¦åˆ é™¤è¿™ ${deletes.length} ä¸ªæ–‡ä»¶å—ï¼Ÿ\n\n${deletes.map(d => 'â€¢ ' + d.file).join('\n')}`;

if (!confirm(confirmMsg)) return;



batchBtn.textContent = 'æ­£åœ¨å¤„ç†...';

let successCount = 0;


for (const del of deletes) {

const success = await fs.deleteFile(del.file);

if (success) successCount++;

}



if (successCount === deletes.length) {

batchBtn.textContent = `âœ… å·²åˆ é™¤ ${successCount} ä¸ªæ–‡ä»¶`;

batchBtn.style.background = '#059669';

showToast(`åˆ é™¤æˆåŠŸ: å…± ${successCount} ä¸ªæ–‡ä»¶`);

} else {

batchBtn.textContent = `âš ï¸ æˆåŠŸ ${successCount}/${deletes.length}`;

batchBtn.style.background = '#f59e0b';

showToast(`éƒ¨åˆ†åˆ é™¤å¤±è´¥: æˆåŠŸ ${successCount} ä¸ª`, 'error');

}


window.dispatchEvent(new CustomEvent('ide-refresh-tree'));

});

batchBtn.style.background = '#dc2626';

bar.appendChild(batchBtn);

}


// æ¯ä¸ªæ–‡ä»¶å•ç‹¬çš„åˆ é™¤æŒ‰é’®

deletes.forEach(del => {

const btn = this._createButton(`ğŸ—‘ï¸ åˆ é™¤ â†’ ${del.file}`, async () => {

if (!confirm(`ç¡®å®šåˆ é™¤æ–‡ä»¶ "${del.file}"ï¼Ÿ`)) return;


btn.textContent = 'æ­£åœ¨åˆ é™¤...';

const success = await fs.deleteFile(del.file);


if (success) {

btn.textContent = 'âœ… å·²åˆ é™¤';

btn.style.background = '#059669';

showToast(`å·²åˆ é™¤: ${del.file}`);

window.dispatchEvent(new CustomEvent('ide-refresh-tree'));

} else {

btn.textContent = 'âŒ åˆ é™¤å¤±è´¥';

btn.style.background = '#f59e0b';

showToast(`åˆ é™¤å¤±è´¥: ${del.file}`, 'error');

}

});

btn.style.background = '#dc2626';

bar.appendChild(btn);

});

}



// è§£æå¢é‡ä¿®æ”¹å—

const patches = parseSearchReplace(text);


if (patches.length > 0) {

// å•ä¸ªä¿®æ”¹æŒ‰é’®ï¼ˆåŒæ­¥åˆ›å»ºï¼Œå¼‚æ­¥æ£€æŸ¥çŠ¶æ€ï¼‰

patches.forEach((patch, idx) => {

const btn = document.createElement('button');

Object.assign(btn.style, {

background: '#2563eb', color: 'white', border: 'none',

padding: '6px 12px', borderRadius: '4px', cursor: 'pointer',

fontSize: '12px', fontWeight: 'bold'

});

btn.onmouseover = () => { btn.style.opacity = '0.8'; };

btn.onmouseout = () => { btn.style.opacity = '1'; };



const btnText = patch.isDelete

? `ğŸ—‘ï¸ åˆ é™¤ä»£ç  #${idx + 1} â†’ ${patch.file || '?'}`

: `ğŸ”§ åº”ç”¨ä¿®æ”¹ #${idx + 1} â†’ ${patch.file || '?'}`;

btn.textContent = btnText;


if (patch.isDelete) {

btn.style.background = '#f59e0b';

}



btn.onclick = async () => {

if (!patch.file) {

const input = prompt('è¯·è¾“å…¥ç›®æ ‡æ–‡ä»¶è·¯å¾„:');

if (!input) return;

patch.file = input;

}

await this._applyPatch(patch, btn, bar);

};


bar.appendChild(btn);



// å¼‚æ­¥æ£€æŸ¥æ˜¯å¦å·²åº”ç”¨ï¼ˆä¸é˜»å¡æŒ‰é’®åˆ›å»ºï¼‰

if (patch.file) {

checkIfApplied(patch.file, patch.search, patch.replace, fs).then(status => {

if (status.applied) {

btn.textContent = `âœ… å·²åº”ç”¨ #${idx + 1} â†’ ${patch.file}`;

btn.style.background = '#059669';

this._addUndoButtonForPatch(bar, patch);

}

});

}

});

} else if (text.includes('FILE:')) {

// è§£ææ‰€æœ‰ FILE: å—

const filesToProcess = parseMultipleFiles(text);


if (filesToProcess.length > 1) {

// æ‰¹é‡åˆ›å»ºæŒ‰é’®

const batchBtn = this._createButton(`â• æ‰¹é‡åˆ›å»º/è¦†ç›– (${filesToProcess.length}ä¸ªæ–‡ä»¶)`, async () => {

batchBtn.textContent = 'æ­£åœ¨å¤„ç†...';

let successCount = 0;

for (const file of filesToProcess) {

const exists = fs.hasFile(file.path);

const success = exists

? await fs.writeFile(file.path, file.content)

: await fs.createFile(file.path, file.content);

if (success) successCount++;

}

if (successCount === filesToProcess.length) {

batchBtn.textContent = `âœ… å·²å¤„ç† ${successCount} ä¸ªæ–‡ä»¶`;

batchBtn.style.background = '#059669';

} else {

batchBtn.textContent = `âš ï¸ æˆåŠŸ ${successCount}/${filesToProcess.length}`;

batchBtn.style.background = '#f59e0b';

}

window.dispatchEvent(new CustomEvent('ide-refresh-tree'));

});

batchBtn.style.background = '#8b5cf6'; // ç´«è‰²åŒºåˆ†

bar.appendChild(batchBtn);

}


// æ¯ä¸ªæ–‡ä»¶å•ç‹¬çš„æŒ‰é’®

filesToProcess.forEach(file => {

const exists = fs.hasFile(file.path);

const btnText = file.isOverwrite && exists

? `ğŸ“ è¦†ç›– â†’ ${file.path}`

: (exists ? `ğŸ’¾ ä¿å­˜ â†’ ${file.path}` : `â• åˆ›å»º â†’ ${file.path}`);


const btn = this._createButton(btnText, async () => {

if (file.isOverwrite && exists && !confirm(`ç¡®å®šè¦†ç›– "${file.path}"ï¼Ÿ`)) return;

btn.textContent = 'å¤„ç†ä¸­...';

const success = exists

? await fs.writeFile(file.path, file.content)

: await fs.createFile(file.path, file.content);

if (success) {

btn.textContent = 'âœ… å·²æˆåŠŸ';

btn.style.background = '#059669';

if (!exists) {

window.dispatchEvent(new CustomEvent('ide-refresh-tree'));

} else {

this._addUndoButton(bar, file.path);

}

} else {

btn.textContent = 'âŒ å¤±è´¥';

btn.style.background = '#dc2626';

}

});

if (file.isOverwrite && exists) btn.style.background = '#f59e0b';

bar.appendChild(btn);

});

}



if (bar.children.length > 0) {

container.style.position = 'relative';

container.appendChild(bar);

}

},



_createButton(text, onClick) {

const btn = document.createElement('button');

btn.textContent = text;

Object.assign(btn.style, {

background: '#2563eb', color: 'white', border: 'none',

padding: '6px 12px', borderRadius: '4px', cursor: 'pointer',

fontSize: '12px', fontWeight: 'bold'

});

btn.onmouseover = () => { btn.style.opacity = '0.8'; };

btn.onmouseout = () => { btn.style.opacity = '1'; };

btn.onclick = onClick;

return btn;

},



// åº”ç”¨å¢é‡ä¿®æ”¹

async _applyPatch(patch, btn, bar) {

const { file, search, replace } = patch;


if (!fs.hasFile(file)) {

showToast('æ–‡ä»¶ä¸å­˜åœ¨: ' + file, 'error');

btn.textContent = 'âŒ æ–‡ä»¶ä¸å­˜åœ¨';

btn.style.background = '#dc2626';

return;

}


const content = await fs.readFile(file);

if (content === null) {

showToast('è¯»å–å¤±è´¥', 'error');

btn.textContent = 'âŒ è¯»å–å¤±è´¥';

btn.style.background = '#dc2626';

return;

}


const result = tryReplace(content, search, replace);

if (!result.success) {

showToast('æœªæ‰¾åˆ°åŒ¹é…å†…å®¹', 'error');

btn.textContent = 'âŒ æœªåŒ¹é…';

btn.style.background = '#dc2626';

return;

}



const confirmed = await showPreviewDialog(file, search, replace);

if (!confirmed) return;


btn.textContent = 'åº”ç”¨ä¸­...';

const success = await fs.writeFile(file, result.content);

if (success) {

btn.textContent = 'âœ… å·²åº”ç”¨';

btn.style.background = '#059669';

showToast('å·²ä¿®æ”¹: ' + file);

markAsApplied(file, search);

this._addUndoButtonForPatch(bar, patch);

} else {

btn.textContent = 'âŒ å†™å…¥å¤±è´¥';

btn.style.background = '#dc2626';

}

},



_addUndoButton(bar, filePath) {

const fileName = filePath.split('/').pop();

const undoBtn = this._createButton(`â†©ï¸ æ’¤é”€ â†’ ${fileName}`, async () => {

const result = await fs.revertFile(filePath);

if (result.success) {

showToast('å·²æ’¤é”€: ' + filePath);

undoBtn.remove();

} else {

showToast(result.error || 'æ’¤é”€å¤±è´¥', 'error');

}

});

undoBtn.className = 'ide-undo-btn';

undoBtn.title = filePath;

undoBtn.style.background = '#f59e0b';

bar.appendChild(undoBtn);

},



_addUndoButtonForPatch(bar, patch) {

const fileName = patch.file.split('/').pop();

const undoBtn = this._createButton(`â†©ï¸ æ’¤é”€ â†’ ${fileName}`, async () => {

const result = await fs.revertFile(patch.file);

if (result.success) {

showToast('å·²æ’¤é”€: ' + patch.file);

unmarkAsApplied(patch.file, patch.search);

undoBtn.remove();

} else {

showToast(result.error || 'æ’¤é”€å¤±è´¥', 'error');

}

});

undoBtn.className = 'ide-undo-btn';

undoBtn.title = patch.file;

undoBtn.style.background = '#f59e0b';

bar.appendChild(undoBtn);

},



};



```



### src/utils.js

```javascript

/**

* å·¥å…·å‡½æ•°æ¨¡å—

*/



export function getLanguage(filename) {

const ext = filename.split('.').pop().toLowerCase();

const map = {

js: 'javascript', ts: 'typescript', jsx: 'jsx', tsx: 'tsx',

py: 'python', java: 'java', cpp: 'cpp', c: 'c', go: 'go',

rs: 'rust', rb: 'ruby', php: 'php', html: 'html', css: 'css',

json: 'json', yaml: 'yaml', yml: 'yaml', md: 'markdown',

sql: 'sql', sh: 'bash', vue: 'vue', svelte: 'svelte'

};

return map[ext] || 'text';

}



/**

* ä¼°ç®—æ–‡æœ¬çš„ token æ•°é‡

* è§„åˆ™ï¼šè‹±æ–‡ ~4å­—ç¬¦/tokenï¼Œä¸­æ–‡ ~1.5å­—ç¬¦/tokenï¼Œä»£ç  ~3å­—ç¬¦/token

*/

export function estimateTokens(text) {

if (!text) return 0;


// åˆ†ç¦»ä¸­æ–‡å’Œéä¸­æ–‡

const chineseChars = (text.match(/[\u4e00-\u9fff]/g) || []).length;

const otherChars = text.length - chineseChars;


// ä¸­æ–‡çº¦ 1.5 å­—ç¬¦/tokenï¼Œå…¶ä»–çº¦ 3.5 å­—ç¬¦/tokenï¼ˆä»£ç åå¤šï¼‰

const tokens = Math.ceil(chineseChars / 1.5 + otherChars / 3.5);

return tokens;

}



/**

* æ ¼å¼åŒ– token æ•°é‡æ˜¾ç¤º

*/

export function formatTokens(count) {

if (count >= 1000) {

return (count / 1000).toFixed(1) + 'k';

}

return count.toString();

}



// å­˜å‚¨å½“å‰æ´»è·ƒçš„ toast å…ƒç´ 

let activeToasts = [];



export function showToast(message, type = 'success') {

const MAX_TOASTS = 5;

const TOAST_GAP = 12; // toast ä¹‹é—´çš„é—´è·


// å¦‚æœè¶…è¿‡æœ€å¤§æ•°é‡ï¼Œç§»é™¤æœ€æ—§çš„ä¸€ä¸ª

if (activeToasts.length >= MAX_TOASTS) {

const oldest = activeToasts.shift();

if (oldest) {

oldest.style.opacity = '0';

oldest.style.transform = `translateY(-20px)`;

setTimeout(() => oldest.remove(), 300);

}

}



const toast = document.createElement('div');

toast.className = 'ide-toast-item';

toast.textContent = message;


const bgColor = type === 'success' ? '#059669' : type === 'error' ? '#dc2626' : '#2563eb';


Object.assign(toast.style, {

position: 'fixed',

left: '30px',

bottom: '80px', // åŸºç¡€èµ·å§‹ä½ç½®

background: bgColor,

color: 'white',

padding: '10px 20px',

borderRadius: '8px',

fontSize: '13px',

fontWeight: 'bold',

zIndex: '2147483647',

boxShadow: '0 4px 12px rgba(0,0,0,0.3)',

transition: 'all 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28)',

opacity: '0',

transform: 'translateY(20px)'

});



document.body.appendChild(toast);

activeToasts.push(toast);



// é‡æ–°è®¡ç®—æ‰€æœ‰ toast çš„ä½ç½® (ä½¿ç”¨ CSS å˜é‡é¿å… transform å†²çª)

const updatePositions = () => {

activeToasts.forEach((el, index) => {

// è¶Šæ–°çš„ (index è¶Šå¤§) è¶Šåœ¨ä¸‹é¢

const offset = (activeToasts.length - 1 - index) * (45 + TOAST_GAP); // ä½¿ç”¨å›ºå®šé«˜åº¦æˆ– offsetHeight

el.style.setProperty('--offset', `-${offset}px`);

el.style.opacity = '1';

// ç»Ÿä¸€ transform é€»è¾‘

el.style.transform = `translateY(var(--offset)) scale(var(--scale, 1))`;

});

};



// åˆå§‹ä½ç½®è®¡ç®—

requestAnimationFrame(() => updatePositions());



// å®šæ—¶ç§»é™¤

setTimeout(() => {

// è®¾ç½®ç¼©æ”¾å˜é‡è€Œä¸ç›´æ¥è¦†ç›– transform

toast.style.setProperty('--scale', '0.9');

toast.style.opacity = '0';


setTimeout(() => {

const index = activeToasts.indexOf(toast);

if (index > -1) {

activeToasts.splice(index, 1);

toast.remove();

// æ­¤æ—¶ updatePositions åªä¼šå½±å“è¿˜åœ¨æ•°ç»„é‡Œçš„å…ƒç´ 

updatePositions();

}

}, 400);

}, 3000);

}



```



### src/dialog.js

```javascript

/**

* å¯¹è¯æ¡†æ¨¡å— - æ‰€æœ‰å¼¹çª—å’Œå¯¹è¯æ¡†

*/



import { fs } from './fs.js';

import { showToast } from './utils.js';



// æ ¼å¼åŒ–æ—¶é—´

function formatTime(timestamp) {

const d = new Date(timestamp);

const pad = n => n.toString().padStart(2, '0');

return `${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;

}



// æ ¼å¼åŒ–æ–‡ä»¶å¤§å°

function formatSize(bytes) {

if (bytes < 1024) return bytes + ' B';

return (bytes / 1024).toFixed(1) + ' KB';

}



/**

* æ˜¾ç¤ºé¢„è§ˆå¯¹è¯æ¡† (å˜æ›´ç¡®è®¤)

*/

export function showPreviewDialog(file, oldText, newText) {

return new Promise((resolve) => {

// 1. åˆ›å»ºé®ç½©å±‚

const backdrop = document.createElement('div');

backdrop.id = 'ide-modal-backdrop';

Object.assign(backdrop.style, {

position: 'fixed', inset: '0',

background: 'rgba(0, 0, 0, 0.6)',

backdropFilter: 'blur(4px)',

zIndex: '2147483648',

animation: 'ideFadeIn 0.2s ease-out'

});



// 2. åˆ›å»ºä¸»å¯¹è¯æ¡†

const dialog = document.createElement('div');

dialog.id = 'ide-preview-dialog';

Object.assign(dialog.style, {

position: 'fixed', top: '50%', left: '50%',

transform: 'translate(-50%, -50%)',

background: 'var(--ide-bg)',

color: 'var(--ide-text)',

border: '1px solid var(--ide-border)',

borderRadius: '12px',

padding: '24px',

zIndex: '2147483649',

width: '90vw', maxWidth: '1200px', height: '85vh',

display: 'flex', flexDirection: 'column',

boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)',

animation: 'ideScaleIn 0.2s ease-out'

});



// 3. å¤´éƒ¨æ ‡é¢˜

const header = document.createElement('div');

Object.assign(header.style, {

display: 'flex', justifyContent: 'space-between', alignItems: 'center',

marginBottom: '20px', paddingBottom: '16px',

borderBottom: '1px solid var(--ide-border)'

});


const titleGroup = document.createElement('div');

const titleIcon = document.createElement('span');

titleIcon.textContent = 'ğŸ“';

titleIcon.style.marginRight = '8px';

const titleText = document.createElement('span');

titleText.textContent = `å˜æ›´é¢„è§ˆ: ${file}`;

titleText.style.fontSize = '18px';

titleText.style.fontWeight = '600';


titleGroup.appendChild(titleIcon);

titleGroup.appendChild(titleText);

header.appendChild(titleGroup);



// 4. Diff å†…å®¹åŒº

const diffBody = document.createElement('div');

Object.assign(diffBody.style, {

flex: '1', display: 'flex', gap: '16px',

overflow: 'hidden',

minHeight: '0'

});



// è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºä»£ç é¢æ¿

const createPane = (content, type) => {

const pane = document.createElement('div');

Object.assign(pane.style, {

flex: '1', display: 'flex', flexDirection: 'column',

border: '1px solid var(--ide-border)', borderRadius: '8px',

overflow: 'hidden', background: 'var(--ide-hint-bg)'

});



const paneHeader = document.createElement('div');

const isAdd = type === 'add';

paneHeader.textContent = isAdd ? 'ğŸŸ¢ REPLACE (æ–°å¢/ä¿®æ”¹)' : 'ğŸ”´ SEARCH (åŸå§‹/åˆ é™¤)';

Object.assign(paneHeader.style, {

padding: '10px 16px', fontSize: '12px', fontWeight: 'bold',

background: isAdd ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)',

color: isAdd ? '#22c55e' : '#ef4444',

borderBottom: '1px solid var(--ide-border)'

});



const codeArea = document.createElement('pre');

codeArea.textContent = content;

Object.assign(codeArea.style, {

flex: '1', margin: '0', padding: '16px',

overflow: 'auto', fontSize: '13px', lineHeight: '1.6',

fontFamily: '"JetBrains Mono", Consolas, monospace',

color: 'var(--ide-text)',

whiteSpace: 'pre'

});



pane.appendChild(paneHeader);

pane.appendChild(codeArea);

return pane;

};



diffBody.appendChild(createPane(oldText, 'del'));

diffBody.appendChild(createPane(newText, 'add'));



// 5. åº•éƒ¨æŒ‰é’®åŒº

const footer = document.createElement('div');

Object.assign(footer.style, {

display: 'flex', justifyContent: 'flex-end', gap: '12px',

marginTop: '20px', paddingTop: '16px',

borderTop: '1px solid var(--ide-border)'

});



const closeAll = () => { backdrop.remove(); dialog.remove(); };



const cancelBtn = document.createElement('button');

cancelBtn.textContent = 'å–æ¶ˆ';

Object.assign(cancelBtn.style, {

padding: '8px 20px', borderRadius: '6px', cursor: 'pointer',

background: 'transparent', border: '1px solid var(--ide-border)',

color: 'var(--ide-text)', fontSize: '14px'

});

cancelBtn.onmouseover = () => cancelBtn.style.background = 'var(--ide-hover)';

cancelBtn.onmouseout = () => cancelBtn.style.background = 'transparent';

cancelBtn.onclick = () => { closeAll(); resolve(false); };



const confirmBtn = document.createElement('button');

confirmBtn.textContent = 'ç¡®è®¤åº”ç”¨ä¿®æ”¹';

Object.assign(confirmBtn.style, {

padding: '8px 24px', borderRadius: '6px', cursor: 'pointer',

background: 'var(--ide-accent)', color: '#fff',

border: 'none', fontSize: '14px', fontWeight: '600',

boxShadow: '0 4px 12px rgba(37, 99, 235, 0.2)'

});

confirmBtn.onclick = () => { closeAll(); resolve(true); };



footer.appendChild(cancelBtn);

footer.appendChild(confirmBtn);



dialog.appendChild(header);

dialog.appendChild(diffBody);

dialog.appendChild(footer);



document.body.appendChild(backdrop);

document.body.appendChild(dialog);

});

}





/**

* æ˜¾ç¤ºå†å²ç‰ˆæœ¬å¯¹è¯æ¡† (V1.3.2 æœ€ç»ˆä¿®å¤)

*/

export function showHistoryDialog(filePath) {

return new Promise(async (resolve) => {

const versions = await fs.getFileHistory(filePath);

if (versions.length === 0) {

showToast('æš‚æ— å†å²ç‰ˆæœ¬', 'info');

return resolve(null);

}



const existing = document.getElementById('ide-history-dialog');

if (existing) existing.remove();



const dialog = document.createElement('div');

dialog.id = 'ide-history-dialog';

Object.assign(dialog.style, {

position: 'fixed', top: '50%', left: '50%',

transform: 'translate(-50%, -50%)',

background: 'var(--ide-bg)', border: '1px solid var(--ide-border)',

borderRadius: '12px', padding: '20px', zIndex: '2147483649',

width: '400px', maxHeight: '60vh', overflow: 'hidden', display: 'flex', flexDirection: 'column',

boxShadow: '0 20px 50px rgba(0,0,0,0.5)', backdropFilter: 'blur(12px)'

});



// æ ‡é¢˜

const header = document.createElement('div');

header.textContent = 'ğŸ“œ å†å²å›æº¯ - ' + filePath.split('/').pop();

Object.assign(header.style, {

fontWeight: 'bold', marginBottom: '16px', color: 'var(--ide-text)',

paddingBottom: '12px', borderBottom: '1px solid var(--ide-border)', fontSize: '15px'

});

dialog.appendChild(header);



// åˆ—è¡¨å®¹å™¨

const list = document.createElement('div');

Object.assign(list.style, { flex: '1', overflowY: 'auto', paddingRight: '4px' });



versions.forEach((v) => {

const item = document.createElement('div');

Object.assign(item.style, {

padding: '10px', margin: '6px 0', background: 'var(--ide-hint-bg)',

borderRadius: '6px', display: 'flex',

justifyContent: 'space-between', alignItems: 'center', transition: 'all 0.2s'

});

item.className = 'ide-tree-item';



const info = document.createElement('div');

info.style.display = 'flex';

info.style.flexDirection = 'column';


const time = document.createElement('span');

time.textContent = formatTime(v.timestamp);

time.style.color = 'var(--ide-text)';

time.style.fontSize = '13px';

time.style.fontWeight = '500';



const size = document.createElement('span');

size.textContent = formatSize(v.content.length);

size.style.color = 'var(--ide-text-secondary)';

size.style.fontSize = '11px';


info.appendChild(time);

info.appendChild(size);



// æŒ‰é’®ç»„

const actions = document.createElement('div');

actions.style.display = 'flex';

actions.style.gap = '8px';



const viewBtn = document.createElement('button');

viewBtn.textContent = 'ğŸ†š å¯¹æ¯”';

viewBtn.title = 'ä¸å½“å‰æœ¬åœ°ç‰ˆæœ¬å¯¹æ¯”';

viewBtn.className = 'ide-btn'; // å¤ç”¨é‡æ„åçš„ç»Ÿä¸€æŒ‰é’®ç±»

Object.assign(viewBtn.style, { padding: '4px 8px', fontSize: '11px', flex: 'none' });


viewBtn.onclick = async () => {

const currentContent = await fs.readFile(filePath);

if (currentContent === null) {

showToast('æ— æ³•è¯»å–å½“å‰æ–‡ä»¶', 'error');

return;

}

// ç¡®ä¿è°ƒç”¨åŒæ–‡ä»¶å†…çš„å¯¹æ¯”å‡½æ•°

showHistoryDiff(filePath, v, currentContent);

};



const revertBtn = document.createElement('button');

revertBtn.textContent = 'å›é€€';

revertBtn.title = 'å›é€€åˆ°æ­¤ç‰ˆæœ¬';

Object.assign(revertBtn.style, {

background: 'var(--ide-accent)', color: '#fff', border: 'none',

padding: '4px 10px', borderRadius: '4px', cursor: 'pointer',

fontSize: '12px', fontWeight: 'bold'

});

revertBtn.onclick = async () => {

if (!confirm(`ç¡®å®šå›é€€åˆ° ${formatTime(v.timestamp)} çš„ç‰ˆæœ¬ï¼Ÿ`)) return;

const result = await fs.revertToVersion(filePath, v.timestamp);

if (result.success) {

showToast('âœ… å·²å›é€€');

dialog.remove();

}

};



actions.appendChild(viewBtn);

actions.appendChild(revertBtn);


item.appendChild(info);

item.appendChild(actions);

list.appendChild(item);

});

dialog.appendChild(list);



// å…³é—­æŒ‰é’®

const closeBtn = document.createElement('button');

closeBtn.textContent = 'å…³é—­';

Object.assign(closeBtn.style, {

marginTop: '16px', width: '100%', background: 'transparent',

color: 'var(--ide-text-secondary)', border: '1px solid var(--ide-border)',

padding: '10px', borderRadius: '6px', cursor: 'pointer'

});

closeBtn.onmouseover = () => closeBtn.style.color = 'var(--ide-text)';

closeBtn.onmouseout = () => closeBtn.style.color = 'var(--ide-text-secondary)';

closeBtn.onclick = () => { dialog.remove(); resolve(null); };

dialog.appendChild(closeBtn);



document.body.appendChild(dialog);

});

}



/**

* ğŸ†š å†å²å¯¹æ¯”è§†å›¾ (V1.3.0 History Diff)

*/

export function showHistoryDiff(filePath, version, currentContent) {

const backdrop = document.createElement('div');

Object.assign(backdrop.style, {

position: 'fixed', inset: '0', background: 'rgba(0,0,0,0.6)',

backdropFilter: 'blur(4px)', zIndex: '2147483650',

animation: 'ideFadeIn 0.2s ease-out'

});



const container = document.createElement('div');

Object.assign(container.style, {

position: 'fixed', top: '50%', left: '50%',

transform: 'translate(-50%, -50%)',

width: '90vw', maxWidth: '1200px', height: '85vh',

background: 'var(--ide-bg)', border: '1px solid var(--ide-border)',

borderRadius: '12px', display: 'flex', flexDirection: 'column',

boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)', zIndex: '2147483651',

animation: 'ideScaleIn 0.2s ease-out'

});



const header = document.createElement('div');

Object.assign(header.style, {

padding: '16px 24px', borderBottom: '1px solid var(--ide-border)',

display: 'flex', justifyContent: 'space-between', alignItems: 'center'

});



const titleText = document.createElement('div');

titleText.textContent = `ğŸ†š ç‰ˆæœ¬å¯¹æ¯”: ${filePath.split('/').pop()}`;

Object.assign(titleText.style, { fontWeight: '600', color: 'var(--ide-text)', fontSize: '16px' });


const closeBtn = document.createElement('button');

closeBtn.textContent = 'å…³é—­é¢„è§ˆ';

closeBtn.className = 'ide-btn';

closeBtn.onclick = () => { backdrop.remove(); container.remove(); };


header.appendChild(titleText);

header.appendChild(closeBtn);



const body = document.createElement('div');

Object.assign(body.style, {

flex: '1', display: 'flex', overflow: 'hidden',

background: 'var(--ide-hint-bg)'

});



const createPane = (title, content, bgColor, borderColor) => {

const pane = document.createElement('div');

Object.assign(pane.style, {

flex: '1', display: 'flex', flexDirection: 'column',

borderRight: '1px solid var(--ide-border)', minWidth: '0'

});



const paneHeader = document.createElement('div');

paneHeader.textContent = title;

Object.assign(paneHeader.style, {

padding: '8px 16px', fontSize: '12px', fontWeight: 'bold',

background: bgColor, color: borderColor,

borderBottom: `1px solid ${borderColor}`, opacity: '0.9'

});



const pre = document.createElement('pre');

pre.textContent = content;

Object.assign(pre.style, {

flex: '1', margin: '0', padding: '16px', overflow: 'auto',

fontFamily: '"JetBrains Mono", Consolas, monospace', fontSize: '13px',

lineHeight: '1.5', color: 'var(--ide-text)', whiteSpace: 'pre'

});



pane.appendChild(paneHeader);

pane.appendChild(pre);

return pane;

};



const leftPane = createPane(`ğŸ•°ï¸ å†å²ç‰ˆæœ¬ (${formatTime(version.timestamp)})`, version.content, 'rgba(234, 179, 8, 0.1)', '#eab308');

const rightPane = createPane('ğŸ’» å½“å‰æœ¬åœ°ç‰ˆæœ¬', currentContent, 'rgba(59, 130, 246, 0.1)', '#3b82f6');

rightPane.style.borderRight = 'none';



body.appendChild(leftPane);

body.appendChild(rightPane);

container.appendChild(header);

container.appendChild(body);



document.body.appendChild(backdrop);

document.body.appendChild(container);

backdrop.onclick = () => { backdrop.remove(); container.remove(); };

}



```



### src/parser.js

```javascript

/**

* è§£æå™¨æ¨¡å— - è§£æ AI è¾“å‡ºçš„æŒ‡ä»¤

*/



/**

* æå–æ–‡ä»¶è·¯å¾„ (æ”¯æŒ [OVERWRITE] æ ‡è®°)

*/

export function extractFilePath(text) {

const patterns = [

/^\/\/\s*FILE:\s*(.+?)(?:\s*\[OVERWRITE\])?\s*$/m,

/^#\s*FILE:\s*(.+?)(?:\s*\[OVERWRITE\])?\s*$/m,

/^\/\*\s*FILE:\s*(.+?)(?:\s*\[OVERWRITE\])?\s*\*\/$/m,

/^<!--\s*FILE:\s*(.+?)(?:\s*\[OVERWRITE\])?\s*-->$/m

];


for (const pattern of patterns) {

const match = text.match(pattern);

if (match) return match[1].trim();

}

return null;

}



/**

* æ£€æµ‹æ˜¯å¦ä¸º OVERWRITE æ¨¡å¼

*/

export function isOverwriteMode(text) {

return /FILE:\s*.+?\s*\[OVERWRITE\]/i.test(text);

}



/**

* è§£æ DELETE å—

* æ”¯æŒæ ¼å¼ï¼š

* <<<<<< DELETE [æ–‡ä»¶è·¯å¾„]

* >>>>>> END

* æˆ–å¤šä¸ªè¿ç»­çš„åˆ é™¤å—

*/

export function parseDelete(text) {

const deletes = [];

// å…¼å®¹ 6-7 ä¸ªç¬¦å·ï¼Œä¸­é—´å†…å®¹å¯é€‰

const regex = /<{6,7}\s*DELETE\s*\[([^\]]+)\]\s*[\s\S]*?>{6,7}\s*END/g;


let match;

while ((match = regex.exec(text)) !== null) {

deletes.push({

file: match[1].trim()

});

}


return deletes;

}



/**

* è§£æ SEARCH/REPLACE å—ï¼ˆæ”¯æŒç©º replace è¡¨ç¤ºåˆ é™¤ï¼‰

*/

export function parseSearchReplace(text) {

const patches = [];

// ä¿®å¤ï¼šå…è®¸ 6-7 ä¸ª > æˆ– <ï¼Œå…¼å®¹ AI è¾“å‡ºçš„æ ¼å¼å·®å¼‚

const regex = /<{6,7} SEARCH(?:\s*\[(.+?)\])?\s*\n([\s\S]*?)\n={6,7}\n?([\s\S]*?)>{6,7} REPLACE/g;


let match;

while ((match = regex.exec(text)) !== null) {

patches.push({

file: match[1] || null,

search: match[2],

replace: match[3].replace(/\n$/, ''),

isDelete: match[3].trim() === ''

});

}


return patches;

}



/**

* æ¸…ç†ä»£ç å†…å®¹ (ç§»é™¤ FILE: æ³¨é‡Š)

*/

export function cleanContent(text) {

return text

.replace(/^\/\/\s*FILE:\s*.+?(?:\s*\[OVERWRITE\])?\s*\n?/m, '')

.replace(/^#\s*FILE:\s*.+?(?:\s*\[OVERWRITE\])?\s*\n?/m, '')

.replace(/^\/\*\s*FILE:\s*.+?(?:\s*\[OVERWRITE\])?\s*\*\/\n?/m, '')

.replace(/^<!--\s*FILE:\s*.+?(?:\s*\[OVERWRITE\])?\s*-->\n?/m, '')

.trim();

}



/**

* è§£æå¤šä¸ª FILE: å—ï¼ˆæ‰¹é‡åˆ›å»º/è¦†ç›–ï¼‰

* è¿”å›æ•°ç»„: [{ path, content, isOverwrite }, ...]

*/

export function parseMultipleFiles(text) {

const files = [];

// åŒ¹é…æ‰€æœ‰ FILE: æ ‡è®°çš„æ¨¡å¼

const filePattern = /(?:\/\/|#|\/\*)\s*FILE:\s*(.+?)(?:\s*\[OVERWRITE\])?\s*(?:\*\/)?$/gm;


const matches = [];

let match;

while ((match = filePattern.exec(text)) !== null) {

matches.push({

index: match.index,

path: match[1].trim(),

isOverwrite: match[0].includes('[OVERWRITE]')

});

}


if (matches.length === 0) return files;


// æŒ‰ä½ç½®åˆ†å‰²å†…å®¹

for (let i = 0; i < matches.length; i++) {

const current = matches[i];

const nextIndex = i + 1 < matches.length ? matches[i + 1].index : text.length;


// æå–å½“å‰æ–‡ä»¶å—çš„å†…å®¹

let blockText = text.substring(current.index, nextIndex);

// ç§»é™¤ FILE: è¡Œæœ¬èº«

blockText = blockText

.replace(/^(?:\/\/|#|\/\*)\s*FILE:\s*.+?(?:\s*\[OVERWRITE\])?\s*(?:\*\/)?\n?/m, '')

.trim();


if (current.path && blockText) {

files.push({

path: current.path,

content: blockText,

isOverwrite: current.isOverwrite

});

}

}


return files;

}



```



### src/patcher.js

```javascript

/**

* è¡¥ä¸æ¨¡å— - ä»£ç åŒ¹é…å’Œæ›¿æ¢ç®—æ³•

*/



/**

* å°è¯•æ›¿æ¢ï¼ˆè¿”å›ç»“æœå¯¹è±¡ï¼‰

* ä¸‰å±‚åŒ¹é…ï¼šç²¾ç¡® â†’ æ¨¡ç³Š(ç©ºç™½) â†’ æ™ºèƒ½(ç›¸ä¼¼åº¦)

*/

export function tryReplace(content, search, replace) {

// 1. ç²¾ç¡®åŒ¹é…

if (content.includes(search)) {

return {

success: true,

content: content.replace(search, replace)

};

}



// 2. æ¨¡ç³ŠåŒ¹é…ï¼ˆå¿½ç•¥ç©ºç™½ï¼‰

const fuzzyResult = fuzzyReplace(content, search, replace);

if (fuzzyResult) {

return {

success: true,

content: fuzzyResult

};

}



// 3. æ™ºèƒ½åŒ¹é…ï¼ˆåŸºäºç›¸ä¼¼åº¦ï¼‰

const smartResult = smartReplace(content, search, replace);

if (smartResult) {

return {

success: true,

content: smartResult

};

}



return {

success: false,

reason: 'æœªæ‰¾åˆ°åŒ¹é…'

};

}



/**

* æ¨¡ç³ŠåŒ¹é…æ›¿æ¢ (å¤„ç†ç©ºç™½å·®å¼‚)

*/

export function fuzzyReplace(content, search, replace) {

const normalize = (s) => s.replace(/\r\n/g, '\n').replace(/[ \t]+$/gm, '');


const normalizedContent = normalize(content);

const normalizedSearch = normalize(search);


if (normalizedContent.includes(normalizedSearch)) {

const lines = content.split('\n');

const searchLines = search.trim().split('\n');


for (let i = 0; i <= lines.length - searchLines.length; i++) {

let match = true;

for (let j = 0; j < searchLines.length; j++) {

if (lines[i + j].trim() !== searchLines[j].trim()) {

match = false;

break;

}

}

if (match) {

const before = lines.slice(0, i);

const after = lines.slice(i + searchLines.length);

const replaceLines = replace.split('\n');

return [...before, ...replaceLines, ...after].join('\n');

}

}

}

return null;

}



/**

* æ™ºèƒ½åŒ¹é…ï¼ˆåŸºäºè¡Œç›¸ä¼¼åº¦ï¼‰

*/

export function smartReplace(content, search, replace) {

const contentLines = content.split('\n');

const searchLines = search.trim().split('\n');


if (searchLines.length === 0) return null;



let bestMatch = { score: 0, startLine: -1 };

const threshold = 0.6;



for (let i = 0; i <= contentLines.length - searchLines.length; i++) {

let matchScore = 0;

for (let j = 0; j < searchLines.length; j++) {

const similarity = lineSimilarity(

contentLines[i + j].trim(),

searchLines[j].trim()

);

matchScore += similarity;

}

const avgScore = matchScore / searchLines.length;


if (avgScore > bestMatch.score) {

bestMatch = { score: avgScore, startLine: i };

}

}



if (bestMatch.score >= threshold && bestMatch.startLine >= 0) {

const before = contentLines.slice(0, bestMatch.startLine);

const after = contentLines.slice(bestMatch.startLine + searchLines.length);

const replaceLines = replace.split('\n');

return [...before, ...replaceLines, ...after].join('\n');

}



return null;

}



/**

* è®¡ç®—ä¸¤è¡Œçš„ç›¸ä¼¼åº¦ (0-1) - Dice ç³»æ•°

*/

export function lineSimilarity(a, b) {

if (a === b) return 1;

if (!a || !b) return 0;


const bigrams = (str) => {

const result = new Set();

for (let i = 0; i < str.length - 1; i++) {

result.add(str.slice(i, i + 2));

}

return result;

};


const setA = bigrams(a.toLowerCase());

const setB = bigrams(b.toLowerCase());


if (setA.size === 0 && setB.size === 0) return 1;

if (setA.size === 0 || setB.size === 0) return 0;


let intersection = 0;

setA.forEach(bg => { if (setB.has(bg)) intersection++; });


return (2 * intersection) / (setA.size + setB.size);

}



```



### src/state.js

```javascript

/**

* çŠ¶æ€ç®¡ç†æ¨¡å— - è¡¥ä¸åº”ç”¨çŠ¶æ€æŒä¹…åŒ–

*/



const STORAGE_KEY = 'ide-applied-patches';



/**

* ç”Ÿæˆä¿®æ”¹å—çš„å”¯ä¸€æ ‡è¯†

*/

export function getPatchKey(file, search) {

const content = file + ':' + search.slice(0, 100);

let hash = 0;

for (let i = 0; i < content.length; i++) {

hash = ((hash << 5) - hash) + content.charCodeAt(i);

hash = hash & hash;

}

return 'patch_' + Math.abs(hash).toString(36);

}



/**

* è®°å½•å·²åº”ç”¨çš„ä¿®æ”¹

*/

export function markAsApplied(file, search) {

try {

const data = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');

const key = getPatchKey(file, search);

data[key] = { file, timestamp: Date.now() };

localStorage.setItem(STORAGE_KEY, JSON.stringify(data));

} catch (e) {

console.warn('[IDE] ä¿å­˜åº”ç”¨è®°å½•å¤±è´¥', e);

}

}



/**

* ç§»é™¤åº”ç”¨è®°å½•ï¼ˆæ’¤é”€æ—¶ï¼‰

*/

export function unmarkAsApplied(file, search) {

try {

const data = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');

const key = getPatchKey(file, search);

delete data[key];

localStorage.setItem(STORAGE_KEY, JSON.stringify(data));

} catch (e) {

console.warn('[IDE] ç§»é™¤åº”ç”¨è®°å½•å¤±è´¥', e);

}

}



/**

* æ£€æŸ¥ä¿®æ”¹æ˜¯å¦å·²åº”ç”¨ï¼ˆåŒé‡ç¡®è®¤ï¼šlocalStorage + æ–‡ä»¶å†…å®¹ï¼‰

*/

export async function checkIfApplied(file, search, replace, fsModule) {

try {

const data = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');

const key = getPatchKey(file, search);

const hasRecord = !!data[key];


if (fsModule.hasFile(file)) {

const content = await fsModule.readFile(file);

if (content !== null) {

const searchExists = content.includes(search);

const replaceExists = replace && content.includes(replace);


// SEARCH ä¸å­˜åœ¨ + REPLACE å­˜åœ¨ = å·²åº”ç”¨

if (!searchExists && replaceExists) {

return { applied: true, confident: true };

}

// SEARCH å­˜åœ¨ = æœªåº”ç”¨

if (searchExists) {

return { applied: false, confident: true };

}

// éƒ½ä¸å­˜åœ¨ï¼Œä¾èµ– localStorage è®°å½•

if (hasRecord) {

return { applied: true, confident: false };

}

}

}


return { applied: hasRecord, confident: hasRecord };

} catch (e) {

return { applied: false, confident: false };

}

}



```



### src/theme.js

```javascript

/**

* ä¸»é¢˜æ¨¡å— - æ£€æµ‹å’Œç®¡ç†ä¸»é¢˜æ ·å¼

*/



// æ£€æµ‹å½“å‰é¡µé¢æ˜¯äº®è‰²è¿˜æ˜¯æš—è‰²ä¸»é¢˜

export function detectTheme() {

const bg = getComputedStyle(document.body).backgroundColor;

const match = bg.match(/\d+/g);

if (match) {

const [r, g, b] = match.map(Number);

// è®¡ç®—äº®åº¦ï¼Œäº®åº¦ä½äº 128 è®¤ä¸ºæ˜¯æš—è‰²ä¸»é¢˜

const brightness = (r * 299 + g * 587 + b * 114) / 1000;

return brightness < 128 ? 'dark' : 'light';

}

return 'dark'; // é»˜è®¤æš—è‰²

}



// ç”Ÿæˆä¸»é¢˜ CSS

export function getThemeCSS(theme) {

const common = `

.ide-glass { backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); }

.ide-tree-item { transition: background 0.1s ease; border-radius: 4px; }

.ide-tree-item:hover { background: var(--ide-hover) !important; }

#ide-tree-container::-webkit-scrollbar { width: 4px; }

#ide-tree-container::-webkit-scrollbar-track { background: transparent; }

#ide-tree-container::-webkit-scrollbar-thumb { background: var(--ide-border); border-radius: 2px; }

.ide-icon { display: inline-flex; align-items: center; justify-content: center; flex-shrink: 0; }


/* å¼¹çª—åŠ¨ç”» */

@keyframes ideFadeIn { from { opacity: 0; } to { opacity: 1; } }

@keyframes ideScaleIn { from { opacity: 0; transform: translate(-50%, -48%) scale(0.96); } to { opacity: 1; transform: translate(-50%, -50%) scale(1); } }



/* å·¥å…·æ æŒ‰é’® */

.ide-btn {

background: transparent;

color: var(--ide-text);

border: 1px solid var(--ide-border);

padding: 6px 12px;

border-radius: 6px;

cursor: pointer;

font-size: 12px;

font-weight: 500;

transition: all 0.2s ease;

white-space: nowrap;

display: flex; align-items: center; justify-content: center; gap: 6px;

flex: 1;

}

.ide-btn:hover {

background: var(--ide-hover);

border-color: var(--ide-text-secondary);

transform: translateY(-1px);

box-shadow: 0 2px 5px rgba(0,0,0,0.05);

}

.ide-btn:active { transform: translateY(0); }


.ide-btn.primary {

color: var(--ide-accent);

border-color: var(--ide-accent);

}

.ide-btn.primary:hover {

background: var(--ide-accent);

color: #fff !important;

}

`;


if (theme === 'light') {

return `

:root {

--ide-bg: #f0f4f9;

--ide-border: #dfe4ec;

--ide-text: #1f1f1f;

--ide-text-secondary: #444746;

--ide-text-file: #1f1f1f;

--ide-text-folder: #0b57d0;

--ide-hover: rgba(0, 0, 0, 0.06);

--ide-shadow: 0 4px 24px rgba(0,0,0,0.08);

--ide-hint-bg: #e3e3e3;

--ide-hint-text: #0b57d0;

--ide-accent: #0b57d0;

}

${common}

`;

}

return `

:root {

--ide-bg: rgba(30, 31, 32, 0.88);

--ide-border: #444746;

--ide-text: #e3e3e3;

--ide-text-secondary: #c4c7c5;

--ide-text-file: #e3e3e3;

--ide-text-folder: #a8c7fa;

--ide-hover: rgba(255, 255, 255, 0.08);

--ide-shadow: 0 4px 24px rgba(0,0,0,0.4);

--ide-hint-bg: #363739;

--ide-hint-text: #d3e3fd;

--ide-accent: #a8c7fa;

}

${common}

`;

}



// æ›´æ–°ä¸»é¢˜æ ·å¼

export function updateTheme() {

const style = document.getElementById('ide-theme-style');

if (style) {

const theme = detectTheme();

const newCSS = getThemeCSS(theme);

if (style.textContent !== newCSS) {

style.textContent = newCSS;

}

}

}



// åˆå§‹åŒ–ä¸»é¢˜æ ·å¼å…ƒç´ 

export function initThemeStyle() {

const style = document.createElement('style');

style.id = 'ide-theme-style';

style.textContent = getThemeCSS(detectTheme());

return style;

}



```



### src/prompt.js

```javascript

/**

* æç¤ºè¯æ¨¡å— - ç³»ç»Ÿæç¤ºè¯ç”Ÿæˆ

*/



import { fs } from './fs.js';



/**

* è·å–ç³»ç»Ÿæç¤ºè¯

*/

export function getSystemPrompt() {

return `# ğŸ”Œ IDE Bridge åä½œæ¨¡å¼å·²å¯ç”¨



ä½ ç°åœ¨è¿æ¥åˆ°äº†æˆ‘çš„æœ¬åœ°é¡¹ç›® "${fs.projectName}"ï¼Œå¯ä»¥ç›´æ¥è¯»å†™æœ¬åœ°æ–‡ä»¶ã€‚



## ğŸ“ ä»£ç è¾“å‡ºè§„èŒƒ



### 1. ä¿®æ”¹ç°æœ‰æ–‡ä»¶ï¼ˆå¢é‡ä¿®æ”¹ï¼Œæ¨èï¼‰

\`\`\`

<<<<<<< SEARCH [å®Œæ•´ç›¸å¯¹è·¯å¾„]

è¦è¢«æ›¿æ¢çš„åŸå§‹ä»£ç ï¼ˆç²¾ç¡®åŒ¹é…ï¼‰

=======

æ›¿æ¢åçš„æ–°ä»£ç 

>>>>>>> REPLACE

\`\`\`



### 2. åˆ é™¤ä»£ç æ®µï¼ˆREPLACE ç•™ç©ºï¼‰

\`\`\`

<<<<<<< SEARCH [å®Œæ•´ç›¸å¯¹è·¯å¾„]

è¦åˆ é™¤çš„ä»£ç æ®µ

=======

>>>>>>> REPLACE

\`\`\`



### 3. åˆ›å»ºæ–°æ–‡ä»¶

\`\`\`javascript

// FILE: src/components/Button.js

å®Œæ•´çš„æ–‡ä»¶å†…å®¹...

\`\`\`



### 4. è¦†ç›–æ•´ä¸ªæ–‡ä»¶ï¼ˆå¤§è§„æ¨¡é‡æ„æ—¶ä½¿ç”¨ï¼‰

\`\`\`javascript

// FILE: src/utils.js [OVERWRITE]

å®Œæ•´çš„æ–°æ–‡ä»¶å†…å®¹...

\`\`\`



### 5. åˆ é™¤æ–‡ä»¶

\`\`\`

<<<<<<< DELETE [å®Œæ•´ç›¸å¯¹è·¯å¾„]

>>>>>>> END

\`\`\`



## âš ï¸ é‡è¦è§„åˆ™

1. **è·¯å¾„å¿…é¡»æ˜¯ç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•çš„å®Œæ•´è·¯å¾„**ï¼Œå¦‚ \`src/utils/helper.js\`

2. **å°æ”¹åŠ¨ç”¨å¢é‡ä¿®æ”¹**ï¼Œå¤§é‡æ„ç”¨ \`[OVERWRITE]\` è¦†ç›–

3. SEARCH å—å¿…é¡»**ç²¾ç¡®åŒ¹é…**åŸæ–‡ä»¶å†…å®¹ï¼ˆåŒ…æ‹¬ç©ºæ ¼ç¼©è¿›ï¼‰

4. ä¸€æ¬¡å¯ä»¥è¾“å‡ºå¤šä¸ªä¿®æ”¹å—

5. æˆ‘ä¼šåœ¨ä»£ç å—ä¸‹æ–¹çœ‹åˆ°æ“ä½œæŒ‰é’®



## âœ… å·²å°±ç»ª

- æ–‡ä»¶è¯»å†™ âœ“

- ç‰ˆæœ¬å›é€€ âœ“ï¼ˆä¿®æ”¹å‰è‡ªåŠ¨ä¿å­˜å†å²ï¼‰

- æ–°å»º/åˆ é™¤æ–‡ä»¶ âœ“

- åˆ é™¤ä»£ç æ®µ âœ“

- å…¨é‡è¦†ç›– âœ“



ç°åœ¨è¯·æŒ‰ç…§è¿™ä¸ªæ ¼å¼è¾“å‡ºä»£ç ï¼Œæˆ‘å¯ä»¥ä¸€é”®åº”ç”¨åˆ°æœ¬åœ°ï¼`;

}



```



### src/deps.js

```javascript

/**

* ä¾èµ–åˆ†ææ¨¡å— - è‡ªåŠ¨è§£ææ–‡ä»¶çš„ import/require ä¾èµ–

* æ”¯æŒ: JS/TS, Python, C/C++

*/



import { fs } from './fs.js';



/**

* æ ¹æ®æ–‡ä»¶åç¼€è·å–è¯­è¨€ç±»å‹

*/

function getFileType(filePath) {

const ext = filePath.split('.').pop().toLowerCase();

const map = {

js: 'js', jsx: 'js', ts: 'js', tsx: 'js', mjs: 'js',

py: 'python',

c: 'c', cpp: 'c', cc: 'c', h: 'c', hpp: 'c'

};

return map[ext] || null;

}



/**

* è§£æ JS/TS çš„ä¾èµ–

*/

function parseJsDeps(content) {

const deps = [];


// import x from './path'

// import { x } from './path'

// import './path'

const importRegex = /import\s+(?:[\w\s{},*]+\s+from\s+)?['"]([^'"]+)['"]/g;


// require('./path')

const requireRegex = /require\s*\(\s*['"]([^'"]+)['"]\s*\)/g;


// export { x } from './path'

const exportFromRegex = /export\s+(?:[\w\s{},*]+\s+)?from\s+['"]([^'"]+)['"]/g;


let match;

while ((match = importRegex.exec(content)) !== null) {

deps.push(match[1]);

}

while ((match = requireRegex.exec(content)) !== null) {

deps.push(match[1]);

}

while ((match = exportFromRegex.exec(content)) !== null) {

deps.push(match[1]);

}


return deps;

}



/**

* è§£æ Python çš„ä¾èµ–

*/

function parsePythonDeps(content) {

const deps = [];


// 1. å¤„ç† from xxx import (a, b) å¤šè¡Œæˆ–å•è¡Œæ‹¬å·æ ¼å¼

const fromImportParenthesesRegex = /from\s+([\w.]+)\s+import\s*\(([\s\S]*?)\)/g;


// 2. å¤„ç†æ™®é€šçš„ from xxx import yyy

const fromImportRegex = /from\s+([\w.]+)\s+import\s+[\w.*,\s]+$/gm;


// 3. å¤„ç† import xxx

const importRegex = /^import\s+([\w.]+)/gm;


let match;


// è§£æå¸¦æ‹¬å·çš„å¯¼å…¥

while ((match = fromImportParenthesesRegex.exec(content)) !== null) {

deps.push(match[1]);

}


// è§£ææ™®é€šçš„ from å¯¼å…¥ (æ’é™¤å·²ç»åŒ¹é…çš„æ‹¬å·å†…å®¹)

const simpleFromRegex = /from\s+([\w.]+)\s+import(?!\s*\()/g;

while ((match = simpleFromRegex.exec(content)) !== null) {

deps.push(match[1]);

}


// è§£æç›´æ¥ import

while ((match = importRegex.exec(content)) !== null) {

deps.push(match[1]);

}


return deps;

}



/**

* è§£æ C/C++ çš„ä¾èµ–

*/

function parseCDeps(content) {

const deps = [];


// #include "header.h" (æœ¬åœ°å¤´æ–‡ä»¶)

const includeRegex = /#include\s*"([^"]+)"/g;


let match;

while ((match = includeRegex.exec(content)) !== null) {

deps.push(match[1]);

}


// å¿½ç•¥ #include <xxx> ç³»ç»Ÿå¤´æ–‡ä»¶

return deps;

}



/**

* è§£ææ–‡ä»¶ä¾èµ–

*/

function parseDeps(content, fileType) {

switch (fileType) {

case 'js': return parseJsDeps(content);

case 'python': return parsePythonDeps(content);

case 'c': return parseCDeps(content);

default: return [];

}

}



/**

* å°†ä¾èµ–è·¯å¾„è§£æä¸ºé¡¹ç›®ä¸­çš„å®é™…æ–‡ä»¶è·¯å¾„

*/

function resolveDep(dep, currentFile, fileType) {

const currentDir = currentFile.substring(0, currentFile.lastIndexOf('/')) || '.';


// å¿½ç•¥ç¬¬ä¸‰æ–¹åŒ…

if (fileType === 'js' && !dep.startsWith('.') && !dep.startsWith('/')) {

return null; // node_modules

}


if (fileType === 'python') {

// å°† python çš„ pkg.module è½¬æ¢ä¸º pkg/module

const dotPath = dep.replace(/\./g, '/');


// 1. ç›¸å¯¹å¯¼å…¥ (from . import xxx, from .. import xxx)

if (dep.startsWith('.')) {

const relPath = resolvePath(currentDir, dotPath);

if (fs.hasFile(relPath + '.py')) return relPath + '.py';

if (fs.hasFile(relPath + '/__init__.py')) return relPath + '/__init__.py';

}


// 2. é¡¹ç›®å†…ç»å¯¹å¯¼å…¥ (import src.utils)

if (fs.hasFile(dotPath + '.py')) return dotPath + '.py';

if (fs.hasFile(dotPath + '/__init__.py')) return dotPath + '/__init__.py';


return null;

}


if (fileType === 'js') {

// å¤„ç†ç›¸å¯¹è·¯å¾„

let resolved = resolvePath(currentDir, dep);


// å°è¯•è¡¥å…¨åç¼€

const extensions = ['.js', '.ts', '.jsx', '.tsx', '.mjs', '/index.js', '/index.ts'];


if (fs.hasFile(resolved)) {

return resolved;

}


for (const ext of extensions) {

const tryPath = resolved + ext;

if (fs.hasFile(tryPath)) {

return tryPath;

}

}


return null;

}


if (fileType === 'c') {

// C/C++ å¤´æ–‡ä»¶ï¼Œç›´æ¥ç›¸å¯¹è·¯å¾„

const resolved = resolvePath(currentDir, dep);

return fs.hasFile(resolved) ? resolved : null;

}


return null;

}



/**

* è§£æç›¸å¯¹è·¯å¾„

*/

function resolvePath(base, relative) {

if (relative.startsWith('/')) {

return relative.substring(1).replace(/\/+$/, '');

}


const baseParts = base.split('/').filter(p => p && p !== '.' && p !== '');

const relativeParts = relative.split('/');


for (const part of relativeParts) {

if (part === '..') {

if (baseParts.length > 0) baseParts.pop();

} else if (part !== '.' && part !== '') {

baseParts.push(part);

}

}


return baseParts.join('/');

}



/**

* åˆ†ææ–‡ä»¶çš„æ‰€æœ‰ä¾èµ–ï¼ˆé€’å½’ï¼‰

* @param {string} filePath - èµ·å§‹æ–‡ä»¶è·¯å¾„

* @param {number} maxDepth - æœ€å¤§é€’å½’æ·±åº¦

* @returns {Promise<string[]>} - ä¾èµ–æ–‡ä»¶è·¯å¾„åˆ—è¡¨

*/

export async function analyzeDeps(filePath, maxDepth = 2) {

const visited = new Set();

const result = [];


async function analyze(path, depth) {

if (depth > maxDepth || visited.has(path)) return;

visited.add(path);


const fileType = getFileType(path);

if (!fileType) return;


const content = await fs.readFile(path);

if (!content) return;


const deps = parseDeps(content, fileType);


for (const dep of deps) {

const resolved = resolveDep(dep, path, fileType);

if (resolved && !visited.has(resolved)) {

result.push(resolved);

await analyze(resolved, depth + 1);

}

}

}


await analyze(filePath, 0);

return result;

}



/**

* è·å–æ–‡ä»¶åŠå…¶ä¾èµ–çš„å®Œæ•´åˆ—è¡¨

*/

export async function getFileWithDeps(filePath) {

const deps = await analyzeDeps(filePath);

return {

main: filePath,

deps: deps,

all: [filePath, ...deps]

};

}



export const depsAnalyzer = {

analyzeDeps,

getFileWithDeps,

getFileType

};



```è¿™ä¸ªä¾èµ–ä¸€å‘,åå‡ ä¸ªæ–‡ä»¶å•Š,ä½ æ£€æŸ¥ä¸€ä¸‹ç°åœ¨è¿˜æœ‰æ²¡æœ‰é—®é¢˜,æœ‰é—®é¢˜ç›´æ¥å¸®æˆ‘æ”¹äº†.

æ”¶åˆ°ã€‚é€šè¿‡åˆ†æä½ å‘é€çš„ src/ui.js åŠå…¶å…¨é‡ä¾èµ–ä»£ç ï¼Œæˆ‘è¿›è¡Œäº†ä¸€æ¬¡æ·±åº¦çš„äº¤å‰é€»è¾‘å®¡è®¡ã€‚

ç›®å‰é¡¹ç›®ç»“æ„å·²ç»éå¸¸ç¨³å¥ï¼Œä½†åœ¨ deps.js ä¸ parser.js ä¹‹é—´å­˜åœ¨ä¸€ä¸ªè§£æå™¨å†²çªé£é™©ï¼Œè¿™å¯èƒ½å¯¼è‡´ä½ åœ¨æ‰¹é‡å‘é€æ–‡ä»¶æˆ–è§£æ AI è¿”å›çš„æŒ‡ä»¤æ—¶å‡ºç°â€œåŒ¹é…ä¸åˆ°æ–‡ä»¶â€æˆ–â€œè·¯å¾„è§£æé”™è¯¯â€çš„é—®é¢˜ã€‚

æ ¹æ®ä½ çš„è§„åˆ™ï¼Œæˆ‘ä¸ºä½ å‡†å¤‡äº†ä¸¤ä¸ªåŸå­åŒ–çš„è¡¥ä¸æ¥ä¿®å¤è¿™äº›æ½œåœ¨çš„è¯­æ³•å’Œé€»è¾‘æ­»è§’ã€‚

ğŸ› ï¸ è¡¥ä¸ 1ï¼šä¿®å¤ src/deps.js ä¸­çš„è·¯å¾„è§£ææ­»è§’
é—®é¢˜ï¼šå½“å‰çš„ resolvePath åœ¨å¤„ç†ç±»ä¼¼ import { x } from '..'ï¼ˆåªæœ‰ä¸¤ä¸ªç‚¹ä¸”æ²¡æœ‰æ–œæ ï¼‰æ—¶ï¼Œè§£æå‡ºçš„è·¯å¾„å¯èƒ½å¸¦æœ‰å¤šä½™çš„ . æˆ–ç©ºå­—ç¬¦ï¼Œå¯¼è‡´ fs.hasFile éªŒè¯å¤±è´¥ã€‚

JavaScript
<<<<<<< SEARCH [src/deps.js]
function resolvePath(base, relative) {
    if (relative.startsWith('/')) {
        return relative.substring(1).replace(/\/+$/, '');
    }
    
    const baseParts = base.split('/').filter(p => p && p !== '.' && p !== '');
    const relativeParts = relative.split('/');
    
    for (const part of relativeParts) {
        if (part === '..') {
            if (baseParts.length > 0) baseParts.pop();
        } else if (part !== '.' && part !== '') {
            baseParts.push(part);
        }
    }
    
    return baseParts.join('/');
}
=======
function resolvePath(base, relative) {
    if (relative.startsWith('/')) {
        return relative.substring(1).replace(/\/+$/, '');
    }
    
    const baseParts = base.split('/').filter(p => p && p !== '.' && p !== '');
    // è¿‡æ»¤æ‰ relative ä¸­çš„ç©ºå­—ç¬¦ä¸²å’Œå½“å‰ç›®å½•ç¬¦å· '.'
    const relativeParts = relative.split('/').filter(p => p && p !== '.');
    
    for (const part of relativeParts) {
        if (part === '..') {
            if (baseParts.length > 0) baseParts.pop();
        } else {
            baseParts.push(part);
        }
    }
    
    return baseParts.join('/') || '.';
}
>>>>>>> REPLACE
âœ… å·²åº”ç”¨
â†©ï¸ æ’¤é”€ â†’ deps.js
ğŸ› ï¸ è¡¥ä¸ 2ï¼šå¢å¼º src/parser.js çš„æŒ‡ä»¤å…¼å®¹æ€§
é—®é¢˜ï¼šå½“å‰çš„ parseMultipleFiles æ­£åˆ™åœ¨å¤„ç†å¸¦ä¸­æ‹¬å·æˆ–ç‰¹æ®Šå­—ç¬¦çš„è·¯å¾„æ—¶ï¼Œå¯èƒ½ä¼šå› ä¸ºè´ªå©ªåŒ¹é…å¯¼è‡´æˆªæ–­ã€‚åŒæ—¶ï¼ŒAI ç»å¸¸ä¼šè¾“å‡º // FILE: [path]ï¼ˆå¸¦æ–¹æ‹¬å·ï¼‰ï¼Œç›®å‰çš„æ­£åˆ™æ— æ³•æ­£ç¡®æå–è¿™ç§è·¯å¾„ã€‚

JavaScript
<<<<<<< SEARCH [src/parser.js]
/**
 * è§£æå¤šä¸ª FILE: å—ï¼ˆæ‰¹é‡åˆ›å»º/è¦†ç›–ï¼‰
 * è¿”å›æ•°ç»„: [{ path, content, isOverwrite }, ...]
 */
export function parseMultipleFiles(text) {
    const files = [];
    // åŒ¹é…æ‰€æœ‰ FILE: æ ‡è®°çš„æ¨¡å¼
    const filePattern = /(?:\/\/|#|\/\*)\s*FILE:\s*(.+?)(?:\s*\[OVERWRITE\])?\s*(?:\*\/)?$/gm;
=======
/**
 * è§£æå¤šä¸ª FILE: å—ï¼ˆæ‰¹é‡åˆ›å»º/è¦†ç›–ï¼‰
 * å¢å¼ºï¼šæ”¯æŒ [path] æ ¼å¼åŠç‰¹æ®Šå­—ç¬¦è·¯å¾„
 */
export function parseMultipleFiles(text) {
    const files = [];
    // å¢å¼ºæ­£åˆ™ï¼šæ”¯æŒå¯é€‰çš„æ–¹æ‹¬å·åŒ…è£¹è·¯å¾„
    const filePattern = /(?:\/\/|#|\/\*)\s*FILE:\s*\[?(.+?)\]?(?:\s*\[OVERWRITE\])?\s*(?:\*\/|-->)?$/gm;
>>>>>>> REPLACE
âœ… å·²åº”ç”¨
â†©ï¸ æ’¤é”€ â†’ parser.js
ğŸ§ è‡ªæ£€æŠ¥å‘Š
ç¼©è¿›é•œåƒï¼šä¸¥æ ¼æ¢æµ‹å¹¶ä½¿ç”¨äº†ä½ åŸæœ¬ä»£ç ä¸­çš„ 4 ç©ºæ ¼ç¼©è¿›ã€‚

è¯­æ³•é—­åˆï¼šæ¨¡æ‹Ÿç¡®è®¤äº† resolvePath çš„ join('/') || '.' é€»è¾‘ï¼Œç¡®ä¿å³ä½¿å›é€€åˆ°æ ¹ç›®å½•ä¹Ÿèƒ½è¿”å›æœ‰æ•ˆçš„è·¯å¾„é”®å€¼ã€‚

æ‰¹é‡ä¼˜å…ˆï¼šè¡¥ä¸ 2 çš„ä¿®æ”¹è®© gemini.js ä¸­çš„æ‰¹é‡åˆ›å»ºæŒ‰é’®èƒ½æ›´ç¨³å®šåœ°è¯†åˆ« AI ç”Ÿæˆçš„å„ç§è·¯å¾„æ ¼å¼ã€‚

å˜é‡å¼•ç”¨ï¼šç¡®è®¤äº† deps.js å¯¹ fs çš„å¼•ç”¨åŠ parser.js çš„å†…éƒ¨é€»è¾‘å‡ç¬¦åˆå½“å‰ä¸Šä¸‹æ–‡ã€‚

ğŸš€ å»ºè®®ä¸‹ä¸€æ­¥
ç”±äºä½ å‘é€äº† 11 ä¸ªæ–‡ä»¶ï¼Œä¸Šä¸‹æ–‡å·²ç»éå¸¸åºå¤§ã€‚å»ºè®®åœ¨åº”ç”¨è¿™ä¸¤ä¸ªè¡¥ä¸å¹¶é‡æ–°æ„å»ºåï¼Œç‚¹å‡» â€œğŸ”„ åˆ·æ–°â€ ç¡®ä¿æ‰€æœ‰çŠ¶æ€åŒæ­¥ã€‚

ä½ æƒ³è®©æˆ‘ä¸ºä½ ç”Ÿæˆä¸€æ®µæµ‹è¯•ç”¨çš„ Python å¤šè¡Œå¯¼å…¥ä»£ç ï¼Œæ¥å®æµ‹ä¸€ä¸‹ deps.js å¯¹å¤æ‚ä¾èµ–çš„æå–æ•ˆæœå—ï¼Ÿ