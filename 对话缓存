非常感谢你提供的详细报错信息和截图，这让我能精准锁定问题的根源。

🔍 诊断报告
Trusted Type 报错：这是因为你的插件（IDE Bridge）在执行“语法检查”或“应用补丁”时，可能使用了 eval() 或 new Function() 来验证代码，而当前页面的 CSP（内容安全策略）禁止了不安全的字符串代码执行。这不代表生成的代码本身有错，而是检查机制被浏览器拦截了。

src/deps.js 语法错误：Kiro 的分析是对的。我之前的补丁在 SEARCH/REPLACE 匹配时，因为缩进或上下文行不匹配，导致替换后的文件结构错乱（比如多出了 return null; }），破坏了 AST 结构。

src/parser.js 垃圾行：cleanContent 的正则不够“贪婪”，没能吃掉 // FILE: 后面的换行符，导致这一行残留在了生成的文件内容中。

🚀 修复方案
我将为你提供 2 个原子化补丁，严格修复这两个核心问题。请按顺序应用。

🛠️ 修复 1：重写 src/deps.js 的 resolveDep (修复语法与逻辑)
这次我直接锁定整个 resolveDep 函数进行全量替换，确保大括号闭合绝对正确，并优化了 Python 的路径探测逻辑（同时尝试“全下划线”和“全横杠”路径）。

JavaScript

<<<<<<< SEARCH [src/deps.js]
/**
 * 将依赖路径解析为项目中的实际文件路径
 */
function resolveDep(dep, currentFile, fileType) {
    const currentDir = currentFile.substring(0, currentFile.lastIndexOf('/')) || '.';
    
    // 忽略第三方包
    if (fileType === 'js' && !dep.startsWith('.') && !dep.startsWith('/')) {
        return null; // node_modules
    }
    
    if (fileType === 'python') {
        // 1. 预处理：提取纯路径并处理变体
        const isRelative = dep.startsWith('.');
        const cleanDep = dep.replace(/^\.+/, '');
        const dotPath = cleanDep.replace(/\./g, '/');
        
        // 生成路径变体：test_lab -> [test_lab, test-lab]
        const pathVariants = [dotPath];
        if (dotPath.includes('_')) pathVariants.push(dotPath.replace(/_/g, '-'));

        for (const p of pathVariants) {
            const candidates = [];
            if (isRelative) {
                // 相对导入：只在当前目录下找
                candidates.push(resolvePath(currentDir, p));
            } else {
                // 绝对/普通导入：先找根目录，再找当前目录（兼容性最强）
                candidates.push(p); 
                candidates.push(resolvePath(currentDir, p));
            }

            for (const cand of candidates) {
                if (!cand) continue;
                // 验证所有可能的后缀
                const fileTry = cand + '.py';
                const pkgTry = cand + '/__init__.py';
                
                if (fs.hasFile(fileTry)) return fileTry;
                if (fs.hasFile(pkgTry)) return pkgTry;
            }
        }
        return null;
    }
    
    if (fileType === 'js') {
        // 处理相对路径
        let resolved = resolvePath(currentDir, dep);
        
        // 尝试补全后缀
        const extensions = ['.js', '.ts', '.jsx', '.tsx', '.mjs', '/index.js', '/index.ts'];
        
        if (fs.hasFile(resolved)) {
            return resolved;
        }
        
        for (const ext of extensions) {
            const tryPath = resolved + ext;
            if (fs.hasFile(tryPath)) {
                return tryPath;
            }
        }
        
        return null;
    }
    
    if (fileType === 'c') {
        // C/C++ 头文件，直接相对路径
        const resolved = resolvePath(currentDir, dep);
        return fs.hasFile(resolved) ? resolved : null;
    }
    
    return null;
}
=======
/**
 * 将依赖路径解析为项目中的实际文件路径
 */
function resolveDep(dep, currentFile, fileType) {
    const currentDir = currentFile.substring(0, currentFile.lastIndexOf('/')) || '.';
    
    // 忽略第三方包
    if (fileType === 'js' && !dep.startsWith('.') && !dep.startsWith('/')) {
        return null; // node_modules
    }
    
    if (fileType === 'python') {
        // 1. 预处理：提取纯路径并处理变体
        const isRelative = dep.startsWith('.');
        const dotPath = dep.replace(/^\.+/, '').replace(/\./g, '/');
        
        // 2. 生成路径变体：解决 test_lab (代码) vs test-lab (目录) 的不一致
        const variants = [dotPath];
        // 尝试：全转横杠 (test_lab/sub -> test-lab/sub)
        if (dotPath.includes('_')) variants.push(dotPath.replace(/_/g, '-'));
        
        for (const p of variants) {
            // 3. 构建探测列表
            const candidates = [];
            if (isRelative) {
                candidates.push(resolvePath(currentDir, p));
            } else {
                // 绝对导入：优先查根目录，其次查当前目录
                candidates.push(p);
                candidates.push(resolvePath(currentDir, p));
            }

            for (const cand of candidates) {
                if (!cand) continue;
                const fileTry = cand + '.py';
                const pkgTry = cand + '/__init__.py';
                
                if (fs.hasFile(fileTry)) return fileTry;
                if (fs.hasFile(pkgTry)) return pkgTry;
            }
        }
        return null;
    }
    
    if (fileType === 'js') {
        let resolved = resolvePath(currentDir, dep);
        const extensions = ['.js', '.ts', '.jsx', '.tsx', '.mjs', '/index.js', '/index.ts'];
        
        if (fs.hasFile(resolved)) return resolved;
        
        for (const ext of extensions) {
            const tryPath = resolved + ext;
            if (fs.hasFile(tryPath)) return tryPath;
        }
        return null;
    }
    
    if (fileType === 'c') {
        const resolved = resolvePath(currentDir, dep);
        return fs.hasFile(resolved) ? resolved : null;
    }
    
    return null;
}
>>>>>>> REPLACE
❌ 语法错误
🛠️ 修复 2：src/parser.js (防止垃圾行写入)
通过增强正则表达式，确保 // FILE: 及其后的换行符被彻底移除，防止路径名污染文件内容。

JavaScript

<<<<<<< SEARCH [src/parser.js]
/**
 * 清理代码内容 (移除 FILE: 注释)
 */
export function cleanContent(text) {
    return text
        .replace(/^\/\/\s*FILE:\s*.+?(?:\s*\[OVERWRITE\])?\s*\n?/m, '')
        .replace(/^#\s*FILE:\s*.+?(?:\s*\[OVERWRITE\])?\s*\n?/m, '')
        .replace(/^\/\*\s*FILE:\s*.+?(?:\s*\[OVERWRITE\])?\s*\*\/\n?/m, '')
        .replace(/^\n?/m, '')
        .trim();
}
=======
/**
 * 清理代码内容 (移除 FILE: 注释)
 * 增强：贪婪匹配整行，防止换行符残留
 */
export function cleanContent(text) {
    return text
        .replace(/^\/\/\s*FILE:.*(?:\r?\n|$)/m, '')
        .replace(/^#\s*FILE:.*(?:\r?\n|$)/m, '')
        .replace(/^\/\*\s*FILE:.*?\*\/(?:\r?\n|$)/m, '')
        .replace(/^(?:\r?\n|$)/m, '')
        .trim();
}
>>>>>>> REPLACE
❌ 语法错误
📝 操作建议
忽略“Trusted Type”红框：只要代码应用成功，你可以暂时忽略那个红色的 Trusted Type 报错，那是插件自我检查机制的误报。

构建验证：应用补丁后，请务必运行 node build.js。

最终测试：刷新页面后，再次右键点击 test-lab/complex_dep.py 执行“发送文件+依赖”。如果一切正常，deps.js 应该能正确识别并发送 sub_module.py。